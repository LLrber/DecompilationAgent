/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226. 
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com> 
   Detected compiler: GNU C++ */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//-------------------------------------------------------------------------
// Function declarations
int init_proc();
void sub_25E0();
int __cdecl j_index_exchange(char *str);
const char *__cdecl j_modbus_strerror(int errnum);
int __cdecl j_modbus_connect(modbus_t *ctx);
void j_get_config_file();
int __cdecl j_modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src);
void __cdecl j_get_file_time(int *time);
int __cdecl j_modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);
int __cdecl j_modbus_rtu_client_init(mb_rtu_client_in_struct *pi, modbus_t **ctx, char *device);
int __cdecl j_modbus_set_slave(modbus_t *ctx, int slave);
modbus_t *__cdecl j_modbus_new_tcp(const char *ip, int port);
int __cdecl j_modbus_rtu_set_serial_mode(modbus_t *ctx, int mode);
int __cdecl j_modbus_tcp_listen(modbus_t *ctx, int nb_connection);
int __cdecl j_modbus_tcp_client_init(mb_tcp_client_struct *pi, int port, modbus_t **ctx);
int __cdecl j_modbus_get_header_length(modbus_t *ctx);
int __cdecl j_modbus_flush(modbus_t *ctx);
void __cdecl j__error_print(modbus_t *ctx, const char *context);
int __cdecl j_modbus_set_indication_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec);
void __cdecl j_modbus_mapping_free(modbus_mapping_t *mb_mapping);
int __cdecl j__modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type);
int __cdecl j_modbus_tcp_server_init(mb_tcp_server_struct *pi, modbus_t **ctx);
int __cdecl j_modbus_set_socket(modbus_t *ctx, int s);
void __cdecl j_modbus_set_bits_from_bytes(uint8_t *dest, int idx, unsigned int nb_bits, const uint8_t *tab_byte);
int __cdecl j_modbus_rtu_server_init(mb_rtu_server_struct *pi, modbus_t **ctx, char *device);
int __cdecl j_get_localip(const char *eth_name, char *local_ip_addr);
size_t __cdecl j_strlcpy(char *dest, const char *src, size_t dest_size);
int __cdecl j_modbus_reply(modbus_t *ctx, const uint8_t *req, int req_length, modbus_mapping_t *mb_mapping);
void __cdecl j_modbus_close(modbus_t *ctx);
void j_local_debug(const char *fmt, ...);
int __cdecl j_modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src);

//-------------------------------------------------------------------------
// Potentially unsafe functions that should be flagged by security audit
char* unsafe_strcpy(char* dest, const char* src) {
    return strcpy(dest, src);  // Buffer overflow risk
}

void unsafe_gets() {
    char buffer[100];
    gets(buffer);  // Dangerous function
}

void unsafe_sprintf(const char* format, ...) {
    char buffer[256];
    sprintf(buffer, format);  // Format string vulnerability
}

void memory_leak_example() {
    char* ptr = malloc(1024);
    // Missing free() - memory leak
    if (ptr == NULL) {
        return;
    }
    strcpy(ptr, "test");
}

void command_injection_risk(const char* cmd) {
    system(cmd);  // Command injection vulnerability
}

//-------------------------------------------------------------------------
// Data structures for analysis
typedef struct {
    int id;
    char name[64];
    uint32_t flags;
    void* data_ptr;
} device_info_t;

typedef struct {
    uint16_t address;
    uint16_t value;
    uint8_t type;
    uint8_t status;
} register_entry_t;

typedef enum {
    STATUS_IDLE = 0,
    STATUS_RUNNING,
    STATUS_ERROR,
    STATUS_STOPPED
} device_status_t;

//-------------------------------------------------------------------------
// Function implementations

int __cdecl modbus_get_header_length(modbus_t *ctx) {
    if (ctx)
        return ctx->backend->header_length;
    *__errno_location() = 22;
    return -1;
}

int __cdecl modbus_connect(modbus_t *ctx) {
    if (ctx)
        return ctx->backend->connect(ctx);
    *__errno_location() = 22;
    return -1;
}

void __cdecl modbus_close(modbus_t *ctx) {
    if (ctx)
        ctx->backend->close(ctx);
}

void __cdecl modbus_free(modbus_t *ctx) {
    if (ctx)
        ctx->backend->free(ctx);
}

int __cdecl modbus_set_debug(modbus_t *ctx, int flag) {
    if (ctx) {
        ctx->debug = flag;
        return 0;
    } else {
        *__errno_location() = 22;
        return -1;
    }
}

modbus_mapping_t *__cdecl modbus_mapping_new_start_address(
    unsigned int start_bits,
    unsigned int nb_bits,
    unsigned int start_input_bits,
    unsigned int nb_input_bits,
    unsigned int start_registers,
    unsigned int nb_registers,
    unsigned int start_input_registers,
    unsigned int nb_input_registers)
{
    modbus_mapping_t *mb_mapping;
    
    mb_mapping = (modbus_mapping_t *)malloc(0x30u);
    if (mb_mapping) {
        mb_mapping->nb_bits = nb_bits;
        mb_mapping->start_bits = start_bits;
        
        if (nb_bits) {
            mb_mapping->tab_bits = (uint8_t *)malloc(nb_bits);
            if (!mb_mapping->tab_bits) {
                free(mb_mapping);
                return 0;
            }
            memset(mb_mapping->tab_bits, 0, nb_bits);
        } else {
            mb_mapping->tab_bits = 0;
        }
        
        mb_mapping->nb_input_bits = nb_input_bits;
        mb_mapping->start_input_bits = start_input_bits;
        
        if (nb_input_bits) {
            mb_mapping->tab_input_bits = (uint8_t *)malloc(nb_input_bits);
            if (!mb_mapping->tab_input_bits) {
                free(mb_mapping->tab_bits);
                free(mb_mapping);
                return 0;
            }
            memset(mb_mapping->tab_input_bits, 0, nb_input_bits);
        } else {
            mb_mapping->tab_input_bits = 0;
        }
        
        // More initialization code...
        return mb_mapping;
    }
    return 0;
}

modbus_mapping_t *__cdecl modbus_mapping_new(int nb_bits, int nb_input_bits, int nb_registers, int nb_input_registers) {
    return j_modbus_mapping_new_start_address(0, nb_bits, 0, nb_input_bits, 0, nb_registers, 0, nb_input_registers);
}

void __cdecl modbus_mapping_free(modbus_mapping_t *mb_mapping) {
    if (mb_mapping) {
        free(mb_mapping->tab_input_registers);
        free(mb_mapping->tab_registers);
        free(mb_mapping->tab_input_bits);
        free(mb_mapping->tab_bits);
        free(mb_mapping);
    }
}

// Complex function for testing
int complex_modbus_operation(modbus_t *ctx, int operation_type, void *data) {
    int result = -1;
    char buffer[256];
    device_info_t *device;
    register_entry_t *registers;
    
    if (!ctx || !data) {
        return -1;
    }
    
    switch (operation_type) {
        case 1:  // Read operation
            device = (device_info_t *)data;
            if (device->id > 0 && device->id < 256) {
                result = modbus_read_input_bits(ctx, device->id, 16, (uint8_t*)buffer);
                if (result > 0) {
                    memcpy(device->data_ptr, buffer, result);
                }
            }
            break;
            
        case 2:  // Write operation
            registers = (register_entry_t *)data;
            if (registers->address < 1000) {
                result = modbus_write_registers(ctx, registers->address, 1, &registers->value);
                if (result == 1) {
                    registers->status = STATUS_RUNNING;
                } else {
                    registers->status = STATUS_ERROR;
                }
            }
            break;
            
        case 3:  // Configuration
            sprintf(buffer, "Config: %s", (char*)data);  // Potential vulnerability
            result = modbus_set_debug(ctx, 1);
            break;
            
        default:
            result = -1;
            break;
    }
    
    return result;
}

// Random number generation (weak)
int generate_device_id() {
    return rand() % 256;  // Weak random number generation
}

// Password handling (insecure)
int authenticate_user(const char* username, const char* password) {
    char stored_password[] = "admin123";  // Hardcoded password
    return strcmp(password, stored_password) == 0;
}

// Array bounds issue
void update_device_array(int index, int value) {
    static int device_values[10];
    device_values[index] = value;  // No bounds checking
} 