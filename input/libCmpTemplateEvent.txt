/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_25E0();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
int __cdecl j_index_exchange(char *str);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
const char *__cdecl j_modbus_strerror(int errnum);
// int strcmp(const char *s1, const char *s2);
int __cdecl j_modbus_connect(modbus_t *ctx);
// int _cxa_finalize(void *);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
void j_get_config_file(); // idb
// int printf(const char *format, ...);
int __cdecl j_modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int tcflush(int fd, int queue_selector);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
void __cdecl j_get_file_time(int *time);
int __cdecl j_modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);
int __cdecl j_modbus_rtu_client_init(mb_rtu_client_in_struct *pi, modbus_t **ctx, char *device);
int __cdecl j_modbus_set_slave(modbus_t *ctx, int slave);
// void free(void *ptr);
// const char *gai_strerror(int ecode);
// char *fgets(char *s, int n, FILE *stream);
modbus_t *__cdecl j_modbus_new_tcp(const char *ip, int port);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
int __cdecl j_modbus_rtu_set_serial_mode(modbus_t *ctx, int mode);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
int __cdecl j_modbus_tcp_listen(modbus_t *ctx, int nb_connection);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *inet_ntoa(struct in_addr in);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
int __cdecl j_modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec);
// uint16_t htons(uint16_t hostshort);
// int __fastcall accept4(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl j_modbus_tcp_client_init(mb_tcp_client_struct *pi, int port, modbus_t **ctx);
int __cdecl j_modbus_get_header_length(modbus_t *ctx);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int ioctl(int fd, unsigned int request, ...);
// int usleep(__useconds_t useconds);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
int __cdecl j_modbus_flush(modbus_t *ctx);
// char *strcpy(char *dest, const char *src);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
void __cdecl j__error_print(modbus_t *ctx, const char *context);
int __cdecl j_modbus_set_indication_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec);
// int puts(const char *s);
// void *malloc(size_t size);
void __cdecl j_modbus_mapping_free(modbus_mapping_t *mb_mapping);
// char *strerror(int errnum);
int j___fxstat(int ver, int fildes, struct stat *stat_buf);
// int _fxstat(int ver, int fildes, struct stat *stat_buf);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// uint32_t ntohl(uint32_t netlong);
// void exit(int status);
int __cdecl j__modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type);
// size_t strlen(const char *s);
int __cdecl j_modbus_tcp_server_init(mb_tcp_server_struct *pi, modbus_t **ctx);
int __cdecl j_modbus_set_socket(modbus_t *ctx, int s);
// int fprintf(FILE *stream, const char *format, ...);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
void __cdecl j_modbus_set_bits_from_bytes(uint8_t *dest, int idx, unsigned int nb_bits, const uint8_t *tab_byte);
// int *_errno_location(void);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// void *memset(void *s, int c, size_t n);
int __cdecl j_modbus_rtu_server_init(mb_rtu_server_struct *pi, modbus_t **ctx, char *device);
// int putchar(int c);
int __cdecl j_get_localip(const char *eth_name, char *local_ip_addr);
size_t __cdecl j_strlcpy(char *dest, const char *src, size_t dest_size);
int __cdecl j_modbus_reply(modbus_t *ctx, const uint8_t *req, int req_length, modbus_mapping_t *mb_mapping);
void __cdecl j_modbus_close(modbus_t *ctx);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
void j_local_debug(const char *fmt, ...);
// int fclose(FILE *stream);
int __cdecl j_modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src);
// void pthread_exit(void *retval);
modbus_mapping_t *__cdecl j_modbus_mapping_new(int nb_bits, int nb_input_bits, int nb_registers, int nb_input_registers);
int __cdecl j_modbus_receive(modbus_t *ctx, uint8_t *req);
// int shutdown(int fd, int how);
// uint32_t htonl(uint32_t hostlong);
// int listen(int fd, int n);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
void __cdecl j_modbus_free(modbus_t *ctx);
// int fputc(int c, FILE *stream);
void __cdecl j__modbus_init_common(modbus_t *ctx);
// int sprintf(char *s, const char *format, ...);
modbus_mapping_t *__cdecl j_modbus_mapping_new_start_address(unsigned int start_bits, unsigned int nb_bits, unsigned int start_input_bits, unsigned int nb_input_bits, unsigned int start_registers, unsigned int nb_registers, unsigned int start_input_registers, unsigned int nb_input_registers);
int __cdecl j_modbus_rtu_set_rts_delay(modbus_t *ctx, int us);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
int __cdecl j_modbus_read_input_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest);
// void freeaddrinfo(struct addrinfo *ai);
modbus_t *__cdecl j_modbus_new_rtu(const char *device, int baud, char parity, int data_bit, int stop_bit);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// in_addr_t inet_addr(const char *cp);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int tcgetattr(int fd, struct termios *termios_p);
int call_weak_fn();
char *deregister_tm_clones();
__int64 register_tm_clones();
char *_do_global_dtors_aux();
__int64 frame_dummy();
void local_debug(const char *fmt, ...);
int __cdecl ComponentEntry(INIT_STRUCT *pInitStruct);
RTS_RESULT ExportFunctions();
RTS_RESULT ImportFunctions();
RTS_UI32 CmpGetVersion(); // idb
RTS_RESULT __cdecl HookFunction(RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2);
void __cdecl CallbackFunction(EventParam *pEventParam);
void __cdecl get_file_time(int *time);
void get_config_file(); // idb
void *__cdecl __noreturn file_changed(void *arg);
void exit_handle(); // idb
void __cdecl handle_signals(int signal_num);
void init_signals(); // idb
void global_var_init(); // idb
void global_var_destory(); // idb
int __cdecl index_exchange(char *str);
void *__cdecl __noreturn rtu_client_func(void *arg);
void __cdecl mb_rtu_client_data__main(mb_rtu_client_data_main_struct *p);
int __cdecl modbus_rtu_client_init(mb_rtu_client_in_struct *pi, modbus_t **ctx, char *device);
void __cdecl mb_rtu_client_in__main(mb_rtu_client_in_main_struct *p);
void *__cdecl rtu_server_func(void *arg);
int __cdecl modbus_rtu_server_init(mb_rtu_server_struct *pi, modbus_t **ctx, char *device);
void __cdecl mb_rtu_server__main(mb_rtu_server_main_struct *p);
int __cdecl modbus_tcp_client_init(mb_tcp_client_struct *pi, int port, modbus_t **ctx);
void *__cdecl __noreturn tcp_client_func(void *arg);
void __cdecl mb_tcp_client__main(mb_tcp_client_main_struct *p);
void *__cdecl tcp_server_func(void *arg);
int __cdecl get_localip(const char *eth_name, char *local_ip_addr);
int __cdecl modbus_tcp_server_init(mb_tcp_server_struct *pi, modbus_t **ctx);
void __cdecl mb_tcp_server__main(mb_tcp_server_main_struct *p);
void __cdecl modbus_set_bits_from_byte(uint8_t *dest, int idx, const uint8_t value);
void __cdecl modbus_set_bits_from_bytes(uint8_t *dest, int idx, unsigned int nb_bits, const uint8_t *tab_byte);
uint8_t __cdecl modbus_get_byte_from_bits(const uint8_t *src, int idx, unsigned int nb_bits);
float __cdecl modbus_get_float_abcd(const uint16_t *src);
float __cdecl modbus_get_float_dcba(const uint16_t *src);
float __cdecl modbus_get_float_badc(const uint16_t *src);
float __cdecl modbus_get_float_cdab(const uint16_t *src);
float __cdecl modbus_get_float(const uint16_t *src);
void __cdecl modbus_set_float_abcd(float f, uint16_t *dest);
void __cdecl modbus_set_float_dcba(float f, uint16_t *dest);
void __cdecl modbus_set_float_badc(float f, uint16_t *dest);
void __cdecl modbus_set_float_cdab(float f, uint16_t *dest);
void __cdecl modbus_set_float(float f, uint16_t *dest);
int __cdecl modbus_set_slave(modbus_t *ctx, int slave);
int __cdecl modbus_rtu_build_request_basis(modbus_t *ctx, int function, int addr, int nb, uint8_t *req);
int __cdecl modbus_rtu_build_response_basis(sft_t *sft, uint8_t *rsp);
uint16_t __cdecl crc16(uint8_t *buffer, uint16_t buffer_length);
int __cdecl modbus_rtu_prepare_response_tid(const uint8_t *req, int *req_length);
int __cdecl modbus_rtu_send_msg_pre(uint8_t *req, int req_length);
void __cdecl modbus_rtu_ioctl_rts(modbus_t *ctx, int on);
ssize_t __cdecl modbus_rtu_send(modbus_t *ctx, const uint8_t *req, int req_length);
int __cdecl modbus_rtu_receive(modbus_t *ctx, uint8_t *req);
ssize_t __cdecl modbus_rtu_recv(modbus_t *ctx, uint8_t *rsp, int rsp_length);
int __cdecl modbus_rtu_pre_check_confirmation(modbus_t *ctx, const uint8_t *req, const uint8_t *rsp, int rsp_length);
int __cdecl modbus_rtu_check_integrity(modbus_t *ctx, uint8_t *msg, const int msg_length);
int __cdecl modbus_rtu_connect(modbus_t *ctx);
int __cdecl modbus_rtu_set_serial_mode(modbus_t *ctx, int mode);
int __cdecl modbus_rtu_get_serial_mode(modbus_t *ctx);
int __cdecl modbus_rtu_get_rts(modbus_t *ctx);
int __cdecl modbus_rtu_set_rts(modbus_t *ctx, int mode);
int __cdecl modbus_rtu_set_custom_rts(modbus_t *ctx, void (*set_rts)(modbus_t *, int));
int __cdecl modbus_rtu_get_rts_delay(modbus_t *ctx);
int __cdecl modbus_rtu_set_rts_delay(modbus_t *ctx, int us);
void __cdecl modbus_rtu_close(modbus_t *ctx);
int __cdecl modbus_rtu_flush(modbus_t *ctx);
int __cdecl modbus_rtu_select(modbus_t *ctx, fd_set *rset, timeval *tv, int length_to_read);
void __cdecl modbus_rtu_free(modbus_t *ctx);
modbus_t *__cdecl modbus_new_rtu(const char *device, int baud, char parity, int data_bit, int stop_bit);
int __cdecl modbus_set_slave_0(modbus_t *ctx, int slave);
int __cdecl modbus_tcp_build_request_basis(modbus_t *ctx, int function, int addr, int nb, uint8_t *req);
int __cdecl modbus_tcp_build_response_basis(sft_t *sft, uint8_t *rsp);
int __cdecl modbus_tcp_prepare_response_tid(const uint8_t *req, int *req_length);
int __cdecl modbus_tcp_send_msg_pre(uint8_t *req, int req_length);
ssize_t __cdecl modbus_tcp_send(modbus_t *ctx, const uint8_t *req, int req_length);
int __cdecl modbus_tcp_receive(modbus_t *ctx, uint8_t *req);
ssize_t __cdecl modbus_tcp_recv(modbus_t *ctx, uint8_t *rsp, int rsp_length);
int __cdecl modbus_tcp_check_integrity(modbus_t *ctx, uint8_t *msg, const int msg_length);
int __cdecl modbus_tcp_pre_check_confirmation(modbus_t *ctx, const uint8_t *req, const uint8_t *rsp, int rsp_length);
int __cdecl modbus_tcp_set_ipv4_options(int s);
int __cdecl connect(int sockfd, const sockaddr *addr, socklen_t addrlen, const timeval *ro_tv);
int __cdecl modbus_tcp_connect(modbus_t *ctx);
int __cdecl modbus_tcp_pi_connect(modbus_t *ctx);
void __cdecl modbus_tcp_close(modbus_t *ctx);
int __cdecl modbus_tcp_flush(modbus_t *ctx);
int __cdecl modbus_tcp_listen(modbus_t *ctx, int nb_connection);
int __cdecl modbus_tcp_pi_listen(modbus_t *ctx, int nb_connection);
int __cdecl modbus_tcp_accept(modbus_t *ctx, int *s);
int __cdecl modbus_tcp_pi_accept(modbus_t *ctx, int *s);
int __cdecl modbus_tcp_select(modbus_t *ctx, fd_set *rset, timeval *tv, int length_to_read);
void __cdecl modbus_tcp_free(modbus_t *ctx);
modbus_t *__cdecl modbus_new_tcp(const char *ip, int port);
modbus_t *__cdecl modbus_new_tcp_pi(const char *node, const char *service);
const char *__cdecl modbus_strerror(int errnum);
void __cdecl error_print(modbus_t *ctx, const char *context);
void __cdecl sleep_response_timeout(modbus_t *ctx);
int __cdecl modbus_flush(modbus_t *ctx);
unsigned int __cdecl compute_response_length_from_request(modbus_t *ctx, uint8_t *req);
int __cdecl send_msg(modbus_t *ctx, uint8_t *msg, int msg_length);
int __cdecl modbus_send_raw_request(modbus_t *ctx, const uint8_t *raw_req, int raw_req_length);
uint8_t __cdecl compute_meta_length_after_function(int function, msg_type_t msg_type);
int __cdecl compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type);
int __cdecl modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type);
int __cdecl modbus_receive(modbus_t *ctx, uint8_t *req);
int __cdecl modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp);
int __cdecl check_confirmation(modbus_t *ctx, uint8_t *req, uint8_t *rsp, int rsp_length);
int __cdecl response_io_status(uint8_t *tab_io_status, int address, int nb, uint8_t *rsp, int offset);
int response_exception(modbus_t *ctx, sft_t *sft, int exception_code, uint8_t *rsp, unsigned int to_flush, const char *template, ...);
int __cdecl modbus_reply(modbus_t *ctx, const uint8_t *req, int req_length, modbus_mapping_t *mb_mapping);
int __cdecl modbus_reply_exception(modbus_t *ctx, const uint8_t *req, unsigned int exception_code);
int __cdecl read_io_status(modbus_t *ctx, int function, int addr, int nb, uint8_t *dest);
int __cdecl modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);
int __cdecl modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);
int __cdecl read_registers(modbus_t *ctx, int function, int addr, int nb, uint16_t *dest);
int __cdecl modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest);
int __cdecl modbus_read_input_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest);
int __cdecl write_single(modbus_t *ctx, int function, int addr, const uint16_t value);
int __cdecl modbus_write_bit(modbus_t *ctx, int addr, int status);
int __cdecl modbus_write_register(modbus_t *ctx, int addr, const uint16_t value);
int __cdecl modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src);
int __cdecl modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src);
int __cdecl modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask, uint16_t or_mask);
int __cdecl modbus_write_and_read_registers(modbus_t *ctx, int write_addr, int write_nb, const uint16_t *src, int read_addr, int read_nb, uint16_t *dest);
int __cdecl modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest);
void __cdecl modbus_init_common(modbus_t *ctx);
int __cdecl modbus_set_slave(modbus_t *ctx, int slave);
int __cdecl modbus_get_slave(modbus_t *ctx);
int __cdecl modbus_set_error_recovery(modbus_t *ctx, modbus_error_recovery_mode error_recovery);
int __cdecl modbus_set_socket(modbus_t *ctx, int s);
int __cdecl modbus_get_socket(modbus_t *ctx);
int __cdecl modbus_get_response_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec);
int __cdecl modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec);
int __cdecl modbus_get_byte_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec);
int __cdecl modbus_set_byte_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec);
int __cdecl modbus_get_indication_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec);
int __cdecl modbus_set_indication_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec);
int __cdecl modbus_get_header_length(modbus_t *ctx);
int __cdecl modbus_connect(modbus_t *ctx);
void __cdecl modbus_close(modbus_t *ctx);
void __cdecl modbus_free(modbus_t *ctx);
int __cdecl modbus_set_debug(modbus_t *ctx, int flag);
modbus_mapping_t *__cdecl modbus_mapping_new_start_address(unsigned int start_bits, unsigned int nb_bits, unsigned int start_input_bits, unsigned int nb_input_bits, unsigned int start_registers, unsigned int nb_registers, unsigned int start_input_registers, unsigned int nb_input_registers);
modbus_mapping_t *__cdecl modbus_mapping_new(int nb_bits, int nb_input_bits, int nb_registers, int nb_input_registers);
void __cdecl modbus_mapping_free(modbus_mapping_t *mb_mapping);
size_t __cdecl strlcpy(char *dest, const char *src, size_t dest_size);
int __fastcall fstat(int fildes, struct stat *stat_buf); // idb
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2);
int _aeabi_ldiv0();
void term_proc();
// int __cxa_finalize(void *);
// int ITM_deregisterTMCloneTable(void); weak
// int Jv_RegisterClasses(void); weak
// int ITM_registerTMCloneTable(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_74 = 2; // weak
_UNKNOWN loc_BE00; // weak
const uint8_t table_crc_hi[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // idb
const uint8_t table_crc_lo[256] =
{
  0u,
  192u,
  193u,
  1u,
  195u,
  3u,
  2u,
  194u,
  198u,
  6u,
  7u,
  199u,
  5u,
  197u,
  196u,
  4u,
  204u,
  12u,
  13u,
  205u,
  15u,
  207u,
  206u,
  14u,
  10u,
  202u,
  203u,
  11u,
  201u,
  9u,
  8u,
  200u,
  216u,
  24u,
  25u,
  217u,
  27u,
  219u,
  218u,
  26u,
  30u,
  222u,
  223u,
  31u,
  221u,
  29u,
  28u,
  220u,
  20u,
  212u,
  213u,
  21u,
  215u,
  23u,
  22u,
  214u,
  210u,
  18u,
  19u,
  211u,
  17u,
  209u,
  208u,
  16u,
  240u,
  48u,
  49u,
  241u,
  51u,
  243u,
  242u,
  50u,
  54u,
  246u,
  247u,
  55u,
  245u,
  53u,
  52u,
  244u,
  60u,
  252u,
  253u,
  61u,
  255u,
  63u,
  62u,
  254u,
  250u,
  58u,
  59u,
  251u,
  57u,
  249u,
  248u,
  56u,
  40u,
  232u,
  233u,
  41u,
  235u,
  43u,
  42u,
  234u,
  238u,
  46u,
  47u,
  239u,
  45u,
  237u,
  236u,
  44u,
  228u,
  36u,
  37u,
  229u,
  39u,
  231u,
  230u,
  38u,
  34u,
  226u,
  227u,
  35u,
  225u,
  33u,
  32u,
  224u,
  160u,
  96u,
  97u,
  161u,
  99u,
  163u,
  162u,
  98u,
  102u,
  166u,
  167u,
  103u,
  165u,
  101u,
  100u,
  164u,
  108u,
  172u,
  173u,
  109u,
  175u,
  111u,
  110u,
  174u,
  170u,
  106u,
  107u,
  171u,
  105u,
  169u,
  168u,
  104u,
  120u,
  184u,
  185u,
  121u,
  187u,
  123u,
  122u,
  186u,
  190u,
  126u,
  127u,
  191u,
  125u,
  189u,
  188u,
  124u,
  180u,
  116u,
  117u,
  181u,
  119u,
  183u,
  182u,
  118u,
  114u,
  178u,
  179u,
  115u,
  177u,
  113u,
  112u,
  176u,
  80u,
  144u,
  145u,
  81u,
  147u,
  83u,
  82u,
  146u,
  150u,
  86u,
  87u,
  151u,
  85u,
  149u,
  148u,
  84u,
  156u,
  92u,
  93u,
  157u,
  95u,
  159u,
  158u,
  94u,
  90u,
  154u,
  155u,
  91u,
  153u,
  89u,
  88u,
  152u,
  136u,
  72u,
  73u,
  137u,
  75u,
  139u,
  138u,
  74u,
  78u,
  142u,
  143u,
  79u,
  141u,
  77u,
  76u,
  140u,
  68u,
  132u,
  133u,
  69u,
  135u,
  71u,
  70u,
  134u,
  130u,
  66u,
  67u,
  131u,
  65u,
  129u,
  128u,
  64u
}; // idb
int _JCR_LIST__ = 0; // weak
const CMP_EXT_FUNCTION_REF s_ItfTable[1] = { { &dword_0, &unk_C0F8, 0u, 0u } }; // idb
const modbus_backend_t modbus_rtu_backend =
{
  0u,
  1u,
  2u,
  256u,
  (int (*)(modbus_t *, int))0x6A79,
  (int (*)(modbus_t *, int, int, int, uint8_t *))0x6AAF,
  (int (*)(sft_t *, uint8_t *))0x6B31,
  (int (*)(const uint8_t *, int *))0x6BD5,
  (int (*)(uint8_t *, int))0x6BF7,
  (ssize_t (*)(modbus_t *, const uint8_t *, int))0x6C93,
  (int (*)(modbus_t *, uint8_t *))0x6D55,
  (ssize_t (*)(modbus_t *, uint8_t *, int))0x6DBD,
  (int (*)(modbus_t *, uint8_t *, const int))0x6E55,
  (int (*)(modbus_t *, const uint8_t *, const uint8_t *, int))0x6DE1,
  (int (*)(modbus_t *))0x6F31,
  (void (*)(modbus_t *))0x7629,
  (int (*)(modbus_t *))0x766B,
  (int (*)(modbus_t *, fd_set *, timeval *, int))0x7689,
  (void (*)(modbus_t *))0x7771
}; // idb
const modbus_backend_t modbus_tcp_backend =
{
  1u,
  7u,
  0u,
  260u,
  (int (*)(modbus_t *, int))0x7959,
  (int (*)(modbus_t *, int, int, int, uint8_t *))0x799F,
  (int (*)(sft_t *, uint8_t *))0x7A4D,
  (int (*)(const uint8_t *, int *))0x7AA5,
  (int (*)(uint8_t *, int))0x7AC9,
  (ssize_t (*)(modbus_t *, const uint8_t *, int))0x7AFD,
  (int (*)(modbus_t *, uint8_t *))0x7B23,
  (ssize_t (*)(modbus_t *, uint8_t *, int))0x7B41,
  (int (*)(modbus_t *, uint8_t *, const int))0x7B65,
  (int (*)(modbus_t *, const uint8_t *, const uint8_t *, int))0x7B7F,
  (int (*)(modbus_t *))0x7DF1,
  (void (*)(modbus_t *))0x8041,
  (int (*)(modbus_t *))0x8079,
  (int (*)(modbus_t *, fd_set *, timeval *, int))0x84D5,
  (void (*)(modbus_t *))0x85BD
}; // idb
const modbus_backend_t modbus_tcp_pi_backend =
{
  1u,
  7u,
  0u,
  260u,
  (int (*)(modbus_t *, int))0x7959,
  (int (*)(modbus_t *, int, int, int, uint8_t *))0x799F,
  (int (*)(sft_t *, uint8_t *))0x7A4D,
  (int (*)(const uint8_t *, int *))0x7AA5,
  (int (*)(uint8_t *, int))0x7AC9,
  (ssize_t (*)(modbus_t *, const uint8_t *, int))0x7AFD,
  (int (*)(modbus_t *, uint8_t *))0x7B23,
  (ssize_t (*)(modbus_t *, uint8_t *, int))0x7B41,
  (int (*)(modbus_t *, uint8_t *, const int))0x7B65,
  (int (*)(modbus_t *, const uint8_t *, const uint8_t *, int))0x7B7F,
  (int (*)(modbus_t *))0x7EE1,
  (void (*)(modbus_t *))0x8041,
  (int (*)(modbus_t *))0x8079,
  (int (*)(modbus_t *, fd_set *, timeval *, int))0x84D5,
  (void (*)(modbus_t *))0x85BD
}; // idb
const CMP_EXT_FUNCTION_REF s_ExternalsTable[6] =
{
  { (RTS_VOID_FCTPTR)0x64F1, "mb_tcp_server__main", 818955626u, 1u },
  { (RTS_VOID_FCTPTR)0x55A1, "mb_tcp_client__main", 3891230929u, 1u },
  { (RTS_VOID_FCTPTR)0x4FBD, "mb_rtu_server__main", 795908213u, 1u },
  { (RTS_VOID_FCTPTR)0x4601, "mb_rtu_client_in__main", 1098896350u, 1u },
  { (RTS_VOID_FCTPTR)0x41D5, "mb_rtu_client_data__main", 2217099933u, 1u },
  { &dword_0, &unk_C0F8, 0u, 0u }
}; // idb
_UNKNOWN *_dso_handle = &_dso_handle; // weak
volatile int g_prog_status = -1; // idb
RTS_HANDLE s_hEventAppDownloadDone = (RTS_HANDLE)0xFFFFFFFF; // idb
RTS_HANDLE s_hEventPrepareWriteVariable = (RTS_HANDLE)0xFFFFFFFF; // idb
RTS_HANDLE s_hEVT_PrepareStart = (RTS_HANDLE)0xFFFFFFFF; // idb
RTS_HANDLE s_hEVT_StartDone = (RTS_HANDLE)0xFFFFFFFF; // idb
RTS_HANDLE s_hEVT_PrepareStop = (RTS_HANDLE)0xFFFFFFFF; // idb
RTS_HANDLE s_hEVT_StopDone = (RTS_HANDLE)0xFFFFFFFF; // idb
RTS_HANDLE s_hEVT_PrepareExit = (RTS_HANDLE)0xFFFFFFFF; // idb
RTS_HANDLE s_hEVT_ExitDone = (RTS_HANDLE)0xFFFFFFFF; // idb
char RTU_DEVICE_NAME[320] =
{
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '3',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '4',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '5',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '6',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '7',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  'd',
  'e',
  'v',
  '/',
  't',
  't',
  'y',
  'm',
  'x',
  'c',
  '8',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char _bss_start; // weak
_UNKNOWN unk_1E3BB; // weak
volatile PF_REGISTER_API s_pfCMRegisterAPI; // idb
volatile PF_REGISTER_API2 s_pfCMRegisterAPI2; // idb
volatile PF_GET_API s_pfCMGetAPI; // idb
volatile PF_GET_API2 s_pfCMGetAPI2; // idb
volatile PF_REGISTER_CLASS s_pfCMRegisterClass; // idb
volatile PF_CREATEINSTANCE s_pfCMCreateInstance; // idb
volatile PF_CALL_HOOK s_pfCMCallHook; // idb
pthread_t config_tid; // idb
PFLOGADD pfLogAdd; // idb
PFEVENTCLOSE pfEventClose; // idb
tcp_client_t tcp_client_data; // idb
rtu_client_t rtu_client_data; // idb
PFEVENTPOST pfEventPost; // idb
FILE *log_fp; // idb
PFEVENTUNREGISTERCALLBACKFUNCTION pfEventUnregisterCallbackFunction; // idb
tcp_server_t tcp_server_data; // idb
PFEVENTOPEN pfEventOpen; // idb
PFEVENTREGISTERCALLBACKFUNCTION pfEventRegisterCallbackFunction; // idb
int cur_time; // idb
rtu_client_data_t rtu_client_cache; // idb
rtu_server_t rtu_server_data; // idb
int last_mod_time; // idb
PFCMUTLMEMCPY pfCMUtlMemCpy; // idb
// extern struct _IO_FILE *stderr;
// extern _UNKNOWN __gmon_start__; weak


//----- (000025D4) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (000025E0) --------------------------------------------------------
void sub_25E0()
{
  JUMPOUT(0);
}
// 25EC: control flows out of bounds to 0

//----- (0000260C) --------------------------------------------------------
// attributes: thunk
int __cdecl j_index_exchange(char *str)
{
  return index_exchange(str);
}

//----- (00002630) --------------------------------------------------------
// attributes: thunk
const char *__cdecl j_modbus_strerror(int errnum)
{
  return modbus_strerror(errnum);
}

//----- (00002648) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_connect(modbus_t *ctx)
{
  return modbus_connect(ctx);
}

//----- (0000266C) --------------------------------------------------------
// attributes: thunk
void j_get_config_file()
{
  get_config_file();
}

//----- (00002684) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src)
{
  return modbus_write_bits(ctx, addr, nb, src);
}

//----- (000026CC) --------------------------------------------------------
// attributes: thunk
void __cdecl j_get_file_time(int *time)
{
  get_file_time(time);
}

//----- (000026D8) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)
{
  return modbus_read_input_bits(ctx, addr, nb, dest);
}

//----- (000026E4) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_rtu_client_init(mb_rtu_client_in_struct *pi, modbus_t **ctx, char *device)
{
  return modbus_rtu_client_init(pi, ctx, device);
}

//----- (000026F0) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_set_slave(modbus_t *ctx, int slave)
{
  return modbus_set_slave(ctx, slave);
}

//----- (00002720) --------------------------------------------------------
// attributes: thunk
modbus_t *__cdecl j_modbus_new_tcp(const char *ip, int port)
{
  return modbus_new_tcp(ip, port);
}

//----- (00002768) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_rtu_set_serial_mode(modbus_t *ctx, int mode)
{
  return modbus_rtu_set_serial_mode(ctx, mode);
}

//----- (0000278C) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_tcp_listen(modbus_t *ctx, int nb_connection)
{
  return modbus_tcp_listen(ctx, nb_connection);
}

//----- (000027C8) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)
{
  return modbus_set_response_timeout(ctx, to_sec, to_usec);
}

//----- (000027EC) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_tcp_client_init(mb_tcp_client_struct *pi, int port, modbus_t **ctx)
{
  return modbus_tcp_client_init(pi, port, ctx);
}

//----- (000027F8) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_get_header_length(modbus_t *ctx)
{
  return modbus_get_header_length(ctx);
}

//----- (00002864) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_flush(modbus_t *ctx)
{
  return modbus_flush(ctx);
}

//----- (00002888) --------------------------------------------------------
// attributes: thunk
void __cdecl j__error_print(modbus_t *ctx, const char *context)
{
  error_print(ctx, context);
}

//----- (00002894) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_set_indication_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)
{
  return modbus_set_indication_timeout(ctx, to_sec, to_usec);
}

//----- (000028B8) --------------------------------------------------------
// attributes: thunk
void __cdecl j_modbus_mapping_free(modbus_mapping_t *mb_mapping)
{
  modbus_mapping_free(mb_mapping);
}

//----- (000028D0) --------------------------------------------------------
// attributes: thunk
int j___fxstat(int ver, int fildes, struct stat *stat_buf)
{
  return _fxstat(ver, fildes, stat_buf);
}

//----- (00002910) --------------------------------------------------------
// attributes: thunk
int __cdecl j__modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)
{
  return modbus_receive_msg(ctx, msg, msg_type);
}

//----- (00002928) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_tcp_server_init(mb_tcp_server_struct *pi, modbus_t **ctx)
{
  return modbus_tcp_server_init(pi, ctx);
}

//----- (00002934) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_set_socket(modbus_t *ctx, int s)
{
  return modbus_set_socket(ctx, s);
}

//----- (00002958) --------------------------------------------------------
// attributes: thunk
void __cdecl j_modbus_set_bits_from_bytes(uint8_t *dest, int idx, unsigned int nb_bits, const uint8_t *tab_byte)
{
  modbus_set_bits_from_bytes(dest, idx, nb_bits, tab_byte);
}

//----- (00002988) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_rtu_server_init(mb_rtu_server_struct *pi, modbus_t **ctx, char *device)
{
  return modbus_rtu_server_init(pi, ctx, device);
}

//----- (000029A0) --------------------------------------------------------
// attributes: thunk
int __cdecl j_get_localip(const char *eth_name, char *local_ip_addr)
{
  return get_localip(eth_name, local_ip_addr);
}

//----- (000029AC) --------------------------------------------------------
// attributes: thunk
size_t __cdecl j_strlcpy(char *dest, const char *src, size_t dest_size)
{
  return strlcpy(dest, src, dest_size);
}

//----- (000029B8) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_reply(modbus_t *ctx, const uint8_t *req, int req_length, modbus_mapping_t *mb_mapping)
{
  return modbus_reply(ctx, req, req_length, mb_mapping);
}

//----- (000029C4) --------------------------------------------------------
// attributes: thunk
void __cdecl j_modbus_close(modbus_t *ctx)
{
  modbus_close(ctx);
}

//----- (000029E8) --------------------------------------------------------
// attributes: thunk
void j_local_debug(const char *fmt, ...)
{
  local_debug(fmt);
}

//----- (00002A00) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src)
{
  return modbus_write_registers(ctx, addr, nb, src);
}

//----- (00002A18) --------------------------------------------------------
// attributes: thunk
modbus_mapping_t *__cdecl j_modbus_mapping_new(
        int nb_bits,
        int nb_input_bits,
        int nb_registers,
        int nb_input_registers)
{
  return modbus_mapping_new(nb_bits, nb_input_bits, nb_registers, nb_input_registers);
}

//----- (00002A24) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_receive(modbus_t *ctx, uint8_t *req)
{
  return modbus_receive(ctx, req);
}

//----- (00002A60) --------------------------------------------------------
// attributes: thunk
void __cdecl j_modbus_free(modbus_t *ctx)
{
  modbus_free(ctx);
}

//----- (00002A78) --------------------------------------------------------
// attributes: thunk
void __cdecl j__modbus_init_common(modbus_t *ctx)
{
  modbus_init_common(ctx);
}

//----- (00002A90) --------------------------------------------------------
// attributes: thunk
modbus_mapping_t *__cdecl j_modbus_mapping_new_start_address(
        unsigned int start_bits,
        unsigned int nb_bits,
        unsigned int start_input_bits,
        unsigned int nb_input_bits,
        unsigned int start_registers,
        unsigned int nb_registers,
        unsigned int start_input_registers,
        unsigned int nb_input_registers)
{
  return modbus_mapping_new_start_address(
           start_bits,
           nb_bits,
           start_input_bits,
           nb_input_bits,
           start_registers,
           nb_registers,
           start_input_registers,
           nb_input_registers);
}

//----- (00002A9C) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_rtu_set_rts_delay(modbus_t *ctx, int us)
{
  return modbus_rtu_set_rts_delay(ctx, us);
}

//----- (00002AC0) --------------------------------------------------------
// attributes: thunk
int __cdecl j_modbus_read_input_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest)
{
  return modbus_read_input_registers(ctx, addr, nb, dest);
}

//----- (00002AD8) --------------------------------------------------------
// attributes: thunk
modbus_t *__cdecl j_modbus_new_rtu(const char *device, int baud, char parity, int data_bit, int stop_bit)
{
  return modbus_new_rtu(device, baud, parity, data_bit, stop_bit);
}

//----- (00002B50) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 28E0: using guessed type int _gmon_start__(void);

//----- (00002B74) --------------------------------------------------------
char *deregister_tm_clones()
{
  char *result; // r0

  result = &_bss_start;
  if ( (unsigned int)(&unk_1E3BB - (_UNKNOWN *)&_bss_start) > 6 )
  {
    if ( &ITM_deregisterTMCloneTable )
      return (char *)ITM_deregisterTMCloneTable();
  }
  return result;
}
// 1E3B8: using guessed type char _bss_start;
// 781DC: using guessed type int ITM_deregisterTMCloneTable(void);

//----- (00002BA4) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &_bss_start;
  HIDWORD(result) = 0;
  return result;
}
// 1E3B8: using guessed type char _bss_start;
// 781E8: using guessed type int ITM_registerTMCloneTable(void);

//----- (00002BD8) --------------------------------------------------------
char *_do_global_dtors_aux()
{
  char *result; // r0

  if ( !_bss_start )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    _bss_start = 1;
  }
  return result;
}
// 1E250: using guessed type _UNKNOWN *_dso_handle;
// 1E3B8: using guessed type char _bss_start;

//----- (00002C18) --------------------------------------------------------
__int64 frame_dummy()
{
  if ( _JCR_LIST__ && &Jv_RegisterClasses )
    Jv_RegisterClasses();
  return register_tm_clones();
}
// 1DDB8: using guessed type int _JCR_LIST__;
// 781E4: using guessed type int Jv_RegisterClasses(void);

//----- (00002C44) --------------------------------------------------------
void local_debug(const char *fmt, ...)
{
  char msg[1028]; // [sp+8h] [bp+8h] BYREF
  va_list varg_r1; // [sp+41Ch] [bp+41Ch] BYREF

  va_start(varg_r1, fmt);
  vsnprintf(msg, 0x400u, fmt, varg_r1);
  fprintf(log_fp, " %s", msg);
}

//----- (00002CA0) --------------------------------------------------------
int __cdecl ComponentEntry(INIT_STRUCT *pInitStruct)
{
  puts("ComponentEntry");
  pInitStruct->CmpId = 73728;
  pInitStruct->pfExportFunctions = ExportFunctions;
  pInitStruct->pfImportFunctions = ImportFunctions;
  pInitStruct->pfGetVersion = CmpGetVersion;
  pInitStruct->pfHookFunction = (PF_HOOK_FUNCTION)HookFunction;
  s_pfCMRegisterAPI = pInitStruct->pfCMRegisterAPI;
  s_pfCMRegisterAPI2 = pInitStruct->pfCMRegisterAPI2;
  s_pfCMGetAPI = pInitStruct->pfCMGetAPI;
  s_pfCMGetAPI2 = pInitStruct->pfCMGetAPI2;
  s_pfCMCallHook = pInitStruct->pfCMCallHook;
  s_pfCMRegisterClass = pInitStruct->pfCMRegisterClass;
  s_pfCMCreateInstance = pInitStruct->pfCMCreateInstance;
  return 0;
}

//----- (00002D5C) --------------------------------------------------------
RTS_RESULT ExportFunctions()
{
  RTS_RESULT ExpResult; // [sp+4h] [bp+4h]
  RTS_RESULT ExpResulta; // [sp+4h] [bp+4h]

  puts("ExportFunctions");
  if ( !s_pfCMRegisterAPI )
    return 3;
  ExpResult = s_pfCMRegisterAPI(s_ExternalsTable, 0, 1, 0x12000u);
  if ( ExpResult )
    return ExpResult;
  ExpResulta = s_pfCMRegisterAPI(s_ItfTable, 0, 0, 0x12000u);
  if ( ExpResulta )
    return ExpResulta;
  else
    return 0;
}

//----- (00002DDC) --------------------------------------------------------
RTS_RESULT ImportFunctions()
{
  RTS_RESULT Result; // [sp+Ch] [bp+4h]

  puts("ImportFunctions");
  s_pfCMGetAPI2("LogAdd", (RTS_VOID_FCTPTR *)&pfLogAdd, 2, 0, 0);
  s_pfCMGetAPI2("CMUtlMemCpy", (RTS_VOID_FCTPTR *)&pfCMUtlMemCpy, 2, 0, 0);
  Result = s_pfCMGetAPI2(
             "EventUnregisterCallbackFunction",
             (RTS_VOID_FCTPTR *)&pfEventUnregisterCallbackFunction,
             0,
             0,
             0);
  if ( !Result )
    Result = s_pfCMGetAPI2(
               "EventRegisterCallbackFunction",
               (RTS_VOID_FCTPTR *)&pfEventRegisterCallbackFunction,
               0,
               0,
               0);
  if ( !Result )
    Result = s_pfCMGetAPI2("EventPost", (RTS_VOID_FCTPTR *)&pfEventPost, 0, 0, 0);
  if ( !Result )
    Result = s_pfCMGetAPI2("EventClose", (RTS_VOID_FCTPTR *)&pfEventClose, 0, 0, 0);
  if ( !Result )
    Result = s_pfCMGetAPI2("EventOpen", (RTS_VOID_FCTPTR *)&pfEventOpen, 0, 0, 0);
  if ( Result )
    return Result;
  else
    return 0;
}
// 2E30: conditional instruction was optimized away because %Result.4==0

//----- (00002F3C) --------------------------------------------------------
RTS_UI32 CmpGetVersion()
{
  puts("CmpGetVersion");
  return 50661642;
}

//----- (00002F5C) --------------------------------------------------------
RTS_RESULT __cdecl HookFunction(RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)
{
  switch ( ulHook )
  {
    case 1u:
      puts("CH_INIT_SYSTEM");
      break;
    case 2u:
      puts("CH_INIT");
      break;
    case 3u:
      puts("CH_INIT2");
      break;
    case 4u:
      puts("CH_INIT3");
      if ( pfEventOpen )
      {
        s_hEVT_PrepareStart = pfEventOpen(0x10001u, 2u, 0);
        s_hEVT_StartDone = pfEventOpen(0x10002u, 2u, 0);
        s_hEVT_PrepareStop = pfEventOpen(0x10003u, 2u, 0);
        s_hEVT_StopDone = pfEventOpen(0x10004u, 2u, 0);
        s_hEVT_PrepareExit = pfEventOpen(0x1000Eu, 2u, 0);
        s_hEVT_ExitDone = pfEventOpen(0x1000Fu, 2u, 0);
      }
      if ( pfEventRegisterCallbackFunction )
      {
        pfEventRegisterCallbackFunction(s_hEVT_PrepareStart, (PFEVENTCALLBACKFUNCTION)CallbackFunction, 0);
        pfEventRegisterCallbackFunction(s_hEVT_StartDone, (PFEVENTCALLBACKFUNCTION)CallbackFunction, 0);
        pfEventRegisterCallbackFunction(s_hEVT_PrepareStop, (PFEVENTCALLBACKFUNCTION)CallbackFunction, 0);
        pfEventRegisterCallbackFunction(s_hEVT_StopDone, (PFEVENTCALLBACKFUNCTION)CallbackFunction, 0);
        pfEventRegisterCallbackFunction(s_hEVT_PrepareExit, (PFEVENTCALLBACKFUNCTION)CallbackFunction, 0);
        pfEventRegisterCallbackFunction(s_hEVT_ExitDone, (PFEVENTCALLBACKFUNCTION)CallbackFunction, 0);
      }
      break;
    case 5u:
      puts("CH_INIT_TASKS");
      break;
    case 6u:
      global_var_init();
      puts("CH_INIT_COMM");
      break;
    case 0xAu:
      global_var_destory();
      puts("CH_EXIT_COMM");
      break;
    case 0xBu:
      puts("CH_EXIT_TASKS");
      break;
    case 0xCu:
      puts("CH_EXIT3");
      if ( pfEventUnregisterCallbackFunction )
      {
        pfEventUnregisterCallbackFunction(s_hEventAppDownloadDone, (PFEVENTCALLBACKFUNCTION)CallbackFunction);
        pfEventUnregisterCallbackFunction(s_hEventPrepareWriteVariable, (PFEVENTCALLBACKFUNCTION)CallbackFunction);
      }
      if ( pfEventClose )
      {
        pfEventClose(s_hEventAppDownloadDone);
        pfEventClose(s_hEventPrepareWriteVariable);
      }
      break;
    case 0xDu:
      puts("CH_EXIT2");
      break;
    case 0xEu:
      puts("CH_EXIT");
      break;
    case 0xFu:
      puts("CH_EXIT_SYSTEM");
      break;
    case 0x14u:
      return 0;
    default:
      puts("default");
      break;
  }
  return 0;
}

//----- (000032B4) --------------------------------------------------------
void __cdecl CallbackFunction(EventParam *pEventParam)
{
  CMPID CmpIdProvider; // r3
  EVTPARAM_CmpMonitorWriteVar2 *pParam_0; // [sp+24h] [bp+Ch]

  CmpIdProvider = pEventParam->CmpIdProvider;
  if ( CmpIdProvider == 2 )
  {
    switch ( pEventParam->EventId )
    {
      case 0x10001u:
        puts("s_hEVT_PrepareStart");
        g_prog_status = 0;
        break;
      case 0x10002u:
        puts("s_hEVT_StartDone");
        g_prog_status = 1;
        j_local_debug("start plc event\n");
        fflush(log_fp);
        break;
      case 0x10003u:
        puts("s_hEVT_PrepareStop");
        g_prog_status = 2;
        break;
      case 0x10004u:
        puts("s_hEVT_StopDone");
        g_prog_status = 3;
        j_local_debug("stop plc event\n");
        fflush(log_fp);
        sleep(1u);
        break;
      case 0x1000Au:
        if ( pEventParam->usVersion )
          pfLogAdd(
            0,
            0x12000u,
            1,
            0,
            0,
            "*** EVT_DownloadDone received: App=%s ***",
            (const char *)(*(_DWORD *)pEventParam->pParameter + 80));
        break;
      case 0x1000Eu:
        puts("s_hEVT_PrepareExit");
        g_prog_status = 4;
        break;
      case 0x1000Fu:
        puts("s_hEVT_ExitDone");
        g_prog_status = 5;
        j_local_debug("exit plc event\n");
        fflush(log_fp);
        break;
      default:
        return;
    }
  }
  else if ( CmpIdProvider == 20 && pEventParam->EventId == 65537 && pEventParam->usVersion > 1u )
  {
    pParam_0 = (EVTPARAM_CmpMonitorWriteVar2 *)pEventParam->pParameter;
    pParam_0->cmpId = 73728;
    pfLogAdd(
      0,
      0x12000u,
      1,
      0,
      0,
      "*** EVT_PrepareWriteVariable received: Size %d Address 0x%x, Value at 0x%x ***",
      pParam_0->usSize,
      pParam_0->pAddress,
      pParam_0->pValue);
  }
}

//----- (000034E0) --------------------------------------------------------
void __cdecl get_file_time(int *time)
{
  stat buf; // [sp+8h] [bp+8h] BYREF
  int fd; // [sp+60h] [bp+60h]
  FILE *fp; // [sp+64h] [bp+64h]

  fp = fopen("/plc/conf/config_file.txt", "r");
  if ( fp )
  {
    fd = fileno(fp);
    fstat(fd, &buf);
    *time = buf.st_mtim.tv_sec;
    fclose(fp);
  }
  else
  {
    *time = 0;
  }
}

//----- (00003538) --------------------------------------------------------
void get_config_file()
{
  char buff[128]; // [sp+0h] [bp+0h] BYREF
  FILE *fp; // [sp+80h] [bp+80h]
  int i; // [sp+84h] [bp+84h]

  i = 0;
  fp = fopen("/plc/conf/config_file.txt", "r");
  memset(buff, 0, sizeof(buff));
LABEL_10:
  while ( fgets(buff, 128, fp) )
  {
    for ( i = 0; strlen(buff) > i; ++i )
    {
      if ( buff[i] == 32 )
      {
        if ( strstr(buff, "rtu_master_query_interval") )
        {
          rtu_client_cache.delay = atoi(&buff[i]);
          printf("rtu delay: %d\n", rtu_client_cache.delay);
        }
        else if ( strstr(buff, "tcp_master_query_interval") )
        {
          tcp_client_data.delay = atoi(&buff[i]);
          printf("tcp_client_data.delay: %d\n", tcp_client_data.delay);
        }
        goto LABEL_10;
      }
    }
  }
}

//----- (00003658) --------------------------------------------------------
void *__cdecl __noreturn file_changed(void *arg)
{
  while ( 1 )
  {
    j_get_file_time(&cur_time);
    if ( last_mod_time != cur_time )
    {
      last_mod_time = cur_time;
      j_get_config_file();
    }
    sleep(1u);
  }
}

//----- (000036A4) --------------------------------------------------------
void exit_handle()
{
  ;
}

//----- (000036B2) --------------------------------------------------------
void __cdecl __noreturn handle_signals(int signal_num)
{
  if ( signal_num == 2 )
    puts("capture an signal:SIGINT.");
  if ( signal_num == 9 )
    puts("capture an signal:SIGKILL.");
  if ( signal_num == 8 )
    puts("capture an signal:SIGFPE.");
  if ( signal_num == 11 )
    puts("capture an signal:SIGSEGV.");
  exit_handle();
  exit(1);
}

//----- (00003714) --------------------------------------------------------
void init_signals()
{
  signal(2, (__sighandler_t)handle_signals);
  signal(9, (__sighandler_t)handle_signals);
  signal(8, (__sighandler_t)handle_signals);
  signal(11, (__sighandler_t)handle_signals);
}

//----- (0000375C) --------------------------------------------------------
void global_var_init()
{
  int j; // [sp+0h] [bp+0h]
  int ja; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]
  int ia; // [sp+4h] [bp+4h]

  log_fp = fopen("./plc.log", "w");
  if ( log_fp )
  {
    init_signals();
    j_get_file_time(&cur_time);
    last_mod_time = cur_time;
    if ( pthread_create(&config_tid, 0, (void *(*)(void *))file_changed, 0) )
    {
      puts("create config thread failed");
    }
    else
    {
      tcp_server_data.tids = (pthread_t *)calloc(0x1FEu, 4u);
      tcp_server_data.tcp_server_ctxs = (modbus_t **)calloc(0x1FEu, 4u);
      tcp_server_data.mb_mappings = (modbus_mapping_t **)calloc(0x1FEu, 4u);
      tcp_server_data.connected = (int *)calloc(0x1FEu, 4u);
      tcp_server_data.pi = (mb_tcp_server_struct **)calloc(0x1FEu, 0x2Cu);
      tcp_client_data.task_runing = 0;
      tcp_client_data.delay = 10;
      tcp_client_data.curse = 0;
      tcp_client_data.pi = (mb_tcp_client_struct **)calloc(0x14u, 0x34u);
      tcp_client_data.tids = (pthread_t *)calloc(0x14u, 4u);
      memset(tcp_client_data.ip, 0, sizeof(tcp_client_data.ip));
      memset(tcp_client_data.port, 0, sizeof(tcp_client_data.port));
      memset(tcp_client_data.length, 0, sizeof(tcp_client_data.length));
      for ( i = 0; i <= 19; ++i )
      {
        for ( j = 500; j < 510; ++j )
        {
          tcp_client_data.adr1[i][j] = (unsigned __int8 *)calloc(0x400u, 1u);
          tcp_client_data.adr2[i][j] = (unsigned __int8 *)calloc(0x400u, 1u);
          tcp_client_data.adr3[i][j] = (unsigned __int16 *)calloc(0x400u, 2u);
          tcp_client_data.adr4[i][j] = (unsigned __int16 *)calloc(0x400u, 2u);
        }
      }
      rtu_client_data.ctxs = (modbus_t **)calloc(0xAu, 4u);
      rtu_client_data.connected = (int *)calloc(0xAu, 4u);
      rtu_client_cache.task_runing = 0;
      rtu_client_cache.delay = 80;
      rtu_client_cache.curse = 0;
      rtu_client_cache.ctxs = (modbus_t **)calloc(0xA00u, 4u);
      rtu_client_cache.tids = (pthread_t *)calloc(0xA00u, 4u);
      rtu_client_cache.connected = (int *)calloc(0xA00u, 4u);
      memset(rtu_client_cache.slava_id, 0, sizeof(rtu_client_cache.slava_id));
      memset(rtu_client_cache.length, 0, sizeof(rtu_client_cache.length));
      memset(rtu_client_cache.slava_id_index, 0, sizeof(rtu_client_cache.slava_id_index));
      pthread_mutex_init(&rtu_client_cache.mutex, 0);
      for ( ia = 0; ia <= 9; ++ia )
      {
        for ( ja = 0; ja <= 255; ++ja )
        {
          rtu_client_cache.adr1[ia][ja] = (unsigned __int8 *)calloc(0x400u, 1u);
          rtu_client_cache.adr2[ia][ja] = (unsigned __int8 *)calloc(0x400u, 1u);
          rtu_client_cache.adr3[ia][ja] = (unsigned __int16 *)calloc(0x400u, 2u);
          rtu_client_cache.adr4[ia][ja] = (unsigned __int16 *)calloc(0x400u, 2u);
        }
      }
      rtu_server_data.tids = (pthread_t *)calloc(0xAu, 4u);
      rtu_server_data.ctxs = (modbus_t **)calloc(0xAu, 4u);
      rtu_server_data.mb_mappings = (modbus_mapping_t **)calloc(0xAu, 4u);
      rtu_server_data.connected = (int *)calloc(0xAu, 4u);
      rtu_server_data.pi = (mb_rtu_server_struct **)calloc(0xAu, 0x7Cu);
      j_local_debug("var init success\n");
      fflush(log_fp);
    }
  }
  else
  {
    puts("open log file failed");
  }
}

//----- (00003BE4) --------------------------------------------------------
void global_var_destory()
{
  int j; // [sp+0h] [bp+0h]
  int ja; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]
  int ia; // [sp+4h] [bp+4h]

  free(tcp_server_data.tids);
  free(tcp_server_data.tcp_server_ctxs);
  free(tcp_server_data.mb_mappings);
  free(tcp_server_data.connected);
  free(tcp_server_data.pi);
  free(tcp_client_data.pi);
  free(tcp_client_data.tids);
  for ( i = 0; i <= 19; ++i )
  {
    for ( j = 0; j < 510; ++j )
    {
      free(tcp_client_data.adr1[i][j]);
      free(tcp_client_data.adr2[i][j]);
      free(tcp_client_data.adr3[i][j]);
      free(tcp_client_data.adr4[i][j]);
    }
  }
  free(rtu_client_data.ctxs);
  free(rtu_client_data.connected);
  free(rtu_client_cache.ctxs);
  free(rtu_client_cache.tids);
  free(rtu_client_cache.connected);
  pthread_mutex_destroy(&rtu_client_cache.mutex);
  for ( ia = 0; ia <= 9; ++ia )
  {
    for ( ja = 0; ja <= 255; ++ja )
    {
      free(rtu_client_cache.adr1[ia][ja]);
      free(rtu_client_cache.adr2[ia][ja]);
      free(rtu_client_cache.adr3[ia][ja]);
      free(rtu_client_cache.adr4[ia][ja]);
    }
  }
  free(rtu_server_data.tids);
  free(rtu_server_data.ctxs);
  free(rtu_server_data.mb_mappings);
  free(rtu_server_data.connected);
  free(rtu_server_data.pi);
  j_local_debug("var destory success\n");
  fflush(log_fp);
  fclose(log_fp);
}

//----- (00003E74) --------------------------------------------------------
int __cdecl index_exchange(char *str)
{
  if ( !strcmp(str, "ttymxc1") )
    return 0;
  if ( !strcmp(str, "ttymxc2") )
    return 1;
  if ( !strcmp(str, "ttymxc3") )
    return 2;
  if ( !strcmp(str, "ttymxc4") )
    return 3;
  if ( !strcmp(str, "ttymxc5") )
    return 4;
  if ( !strcmp(str, "ttymxc6") )
    return 5;
  if ( !strcmp(str, "ttymxc7") )
    return 6;
  if ( !strcmp(str, "ttymxc8") )
    return 7;
  return -1;
}

//----- (00003F68) --------------------------------------------------------
void *__cdecl __noreturn rtu_client_func(void *arg)
{
  pthread_t v1; // r0
  bool v2; // nf
  int v3; // r2
  int v4; // r3
  int v5; // r5
  int *v6; // r0
  const char *v7; // r0
  int *v8; // r0
  const char *v9; // r0
  int *v10; // r0
  const char *v11; // r0
  int *v12; // r0
  const char *v13; // r0
  modbus_t *ctx; // [sp+Ch] [bp+Ch]
  int slave_id; // [sp+10h] [bp+10h]
  int index; // [sp+14h] [bp+14h]
  int i; // [sp+1Ch] [bp+1Ch]

  v1 = pthread_self();
  pthread_detach(v1);
  index = j_index_exchange((char *)arg + 4);
  ctx = (modbus_t *)*((_DWORD *)&rtu_client_cache.ctxs[256 * index] + *((unsigned __int16 *)arg + 44));
  while ( 1 )
  {
    while ( g_prog_status != 1 )
      sleep(1u);
    pthread_mutex_lock(&rtu_client_cache.mutex);
    usleep(rtu_client_cache.delay);
    for ( i = 0; rtu_client_cache.curse > i; ++i )
    {
      v4 = rtu_client_cache.slava_id_index[i];
      v3 = -v4;
      v2 = -v4 < 0;
      v4 = (unsigned __int8)v4;
      if ( !v2 )
        v4 = -(unsigned __int8)v3;
      slave_id = v4;
      j_modbus_set_slave(ctx, v4);
      if ( j_modbus_read_input_registers(
             ctx,
             0,
             rtu_client_cache.length[index][slave_id][3],
             rtu_client_cache.adr4[index][slave_id]) == -1 )
      {
        v5 = *_errno_location();
        v6 = _errno_location();
        v7 = j_modbus_strerror(*v6);
        printf("modbus_read_input_registers error: %d---%s\n", v5, v7);
      }
      if ( j_modbus_read_input_bits(
             ctx,
             0,
             rtu_client_cache.length[index][slave_id][1],
             rtu_client_cache.adr2[index][slave_id]) == -1 )
      {
        v8 = _errno_location();
        v9 = j_modbus_strerror(*v8);
        printf("modbus_read_input_bits error: %s\n", v9);
      }
      if ( j_modbus_write_bits(
             ctx,
             0,
             rtu_client_cache.length[index][slave_id][0],
             rtu_client_cache.adr1[index][slave_id]) == -1 )
      {
        v10 = _errno_location();
        v11 = j_modbus_strerror(*v10);
        printf("modbus_write_bits error: %s\n", v11);
      }
      if ( j_modbus_write_registers(
             ctx,
             0,
             rtu_client_cache.length[index][slave_id][2],
             rtu_client_cache.adr3[index][slave_id]) == -1 )
      {
        v12 = _errno_location();
        v13 = j_modbus_strerror(*v12);
        printf("modbus_write_registers error: %s\n", v13);
      }
    }
    pthread_mutex_unlock(&rtu_client_cache.mutex);
  }
}

//----- (000041D4) --------------------------------------------------------
void __cdecl mb_rtu_client_data__main(mb_rtu_client_data_main_struct *p)
{
  int v1; // r3
  int slave_id; // [sp+8h] [bp+8h]
  mb_rtu_client_data_struct *pi; // [sp+Ch] [bp+Ch]
  int index; // [sp+14h] [bp+14h]

  pi = p->pInstance;
  if ( p->pInstance->First )
  {
    index = j_index_exchange(pi->Device);
    if ( index >= 0 )
    {
      if ( rtu_client_data.connected[index] )
      {
        slave_id = pi->Slave;
        if ( !rtu_client_cache.slava_id[256 * index + slave_id] )
        {
          printf("== index: %d, slave_id: %d\n", index, slave_id);
          *((_DWORD *)&rtu_client_cache.ctxs[256 * index] + slave_id) = rtu_client_data.ctxs[index];
          rtu_client_cache.connected[256 * index + slave_id] = 1;
          rtu_client_cache.slava_id[256 * index + slave_id] = 1;
          v1 = rtu_client_cache.curse++;
          rtu_client_cache.slava_id_index[v1] = slave_id + (index << 8);
          rtu_client_cache.length[index][slave_id][0] = pi->N01;
          rtu_client_cache.length[index][slave_id][1] = pi->N02;
          rtu_client_cache.length[index][slave_id][2] = pi->N03;
          rtu_client_cache.length[index][slave_id][3] = pi->N04;
          usleep(0x64u);
          if ( rtu_client_cache.task_runing
            || !pthread_create(
                  &rtu_client_cache.tids[256 * index + slave_id],
                  0,
                  (void *(*)(void *))rtu_client_func,
                  pi) )
          {
            rtu_client_cache.task_runing = 1;
            pi->Err = 0;
            j_local_debug("rtu master thread create success\n");
            fflush(log_fp);
          }
          else
          {
            pi->Err = 1;
            j_local_debug("rtu master thread create failed\n");
            fflush(log_fp);
          }
        }
        if ( !pi->Done )
        {
          if ( pi->N02 )
            memcpy(pi->Adr02, rtu_client_cache.adr2[index][slave_id], pi->N02);
          if ( pi->N04 )
            memcpy(pi->Adr04, rtu_client_cache.adr4[index][slave_id], pi->N04);
          if ( pi->N01 )
            memcpy(rtu_client_cache.adr1[index][slave_id], pi->Adr01, pi->N01);
          if ( pi->N03 )
            memcpy(rtu_client_cache.adr3[index][slave_id], pi->Adr03, pi->N03);
          pi->Err = 0;
          pi->Done = 1;
        }
      }
      else
      {
        pi->Done = 1;
        pi->Err = 1;
      }
    }
    else
    {
      pi->Done = 1;
      pi->Err = 1;
    }
  }
  else
  {
    pi->Err = 0;
    pi->Done = 0;
  }
}

//----- (000044FC) --------------------------------------------------------
int __cdecl modbus_rtu_client_init(mb_rtu_client_in_struct *pi, modbus_t **ctx, char *device)
{
  modbus_t *v4; // r0

  if ( pi->Parity )
  {
    if ( pi->Parity == 1 )
    {
      puts("CRC: E");
      v4 = j_modbus_new_rtu(device, pi->Baud, 69, 8, 1);
    }
    else
    {
      if ( pi->Parity != 2 )
      {
        puts("error parity para");
        return -1;
      }
      puts("CRC: O");
      v4 = j_modbus_new_rtu(device, pi->Baud, 79, 8, 1);
    }
  }
  else
  {
    puts("CRC: N");
    v4 = j_modbus_new_rtu(device, pi->Baud, 78, 8, 1);
  }
  *ctx = v4;
  if ( !*ctx )
    return -1;
  j_modbus_set_response_timeout(*ctx, 2u, 0);
  pi->INIDone = 1;
  j_local_debug("rtu master init success, CRC: %d, baud: %d\n", pi->Parity, pi->Baud);
  fflush(log_fp);
  return 0;
}

//----- (00004600) --------------------------------------------------------
void __cdecl mb_rtu_client_in__main(mb_rtu_client_in_main_struct *p)
{
  mb_rtu_client_in_struct *pi; // [sp+8h] [bp+8h]
  int index; // [sp+Ch] [bp+Ch]
  int indexa; // [sp+Ch] [bp+Ch]

  pi = p->pInstance;
  if ( p->pInstance->DISCONNECT == 1 )
  {
    index = j_index_exchange(pi->Device);
    if ( index >= 0 )
    {
      if ( rtu_client_data.connected[index] == 1 )
      {
        j_local_debug("rtu master disconnect success\n");
        fflush(log_fp);
        j_modbus_close(rtu_client_data.ctxs[index]);
        j_modbus_free(rtu_client_data.ctxs[index]);
        rtu_client_data.ctxs[index] = 0;
        rtu_client_data.connected[index] = 0;
        pi->INIDone = 0;
        pi->Err = 0;
      }
    }
    else
    {
      pi->Err = 1;
    }
  }
  else
  {
    indexa = j_index_exchange(pi->Device);
    if ( indexa >= 0 )
    {
      if ( rtu_client_data.connected[indexa] )
      {
        pi->INIDone = 1;
      }
      else if ( j_modbus_rtu_client_init(pi, &rtu_client_data.ctxs[indexa], &RTU_DEVICE_NAME[32 * indexa]) )
      {
        j_local_debug("rtu master init failed\n");
        fflush(log_fp);
        pi->Err = 1;
      }
      else if ( j_modbus_connect(rtu_client_data.ctxs[indexa]) == -1 )
      {
        pi->Err = 1;
        j_modbus_free(rtu_client_data.ctxs[indexa]);
        j_local_debug("rtu master connect failed\n");
        fflush(log_fp);
      }
      else
      {
        puts("rtu master modbus client connect success");
        pi->Err = 0;
        rtu_client_data.connected[indexa] = 1;
      }
    }
    else
    {
      pi->Err = 1;
    }
  }
}

//----- (000047D8) --------------------------------------------------------
void *__cdecl rtu_server_func(void *arg)
{
  pthread_t v1; // r0
  modbus_mapping_t **v2; // r5
  struct _IO_FILE *v3; // r4
  int *v4; // r0
  const char *v5; // r0
  struct _IO_FILE *v6; // r4
  int *v7; // r0
  const char *v8; // r0
  uint8_t query[260]; // [sp+Ch] [bp+Ch] BYREF
  int data; // [sp+110h] [bp+110h]
  int address; // [sp+114h] [bp+114h]
  int rc; // [sp+118h] [bp+118h]
  int header_length; // [sp+11Ch] [bp+11Ch]
  modbus_t *ctx1; // [sp+120h] [bp+120h]
  int index; // [sp+124h] [bp+124h]
  mb_rtu_server_struct *pi; // [sp+128h] [bp+128h]
  int i; // [sp+12Ch] [bp+12Ch]

  v1 = pthread_self();
  pthread_detach(v1);
  pi = (mb_rtu_server_struct *)arg;
  index = j_index_exchange((char *)arg + 4);
  v2 = &rtu_server_data.mb_mappings[index];
  *v2 = j_modbus_mapping_new(2000, 1968, 125, 123);
  if ( rtu_server_data.mb_mappings[index] )
  {
    j_local_debug("rtu slave mapping success\n");
    fflush(log_fp);
    ctx1 = rtu_server_data.ctxs[index];
    if ( j_modbus_connect(ctx1) != -1 )
    {
      j_local_debug("rtu slave connected success\n");
      fflush(log_fp);
      header_length = 1;
      j_local_debug("init rtu slave register\n");
      fflush(log_fp);
      for ( i = 0; pi->N01 > i; ++i )
        rtu_server_data.mb_mappings[index]->tab_bits[i] = pi->Adr01[i];
      for ( i = 0; pi->N02 > i; ++i )
        rtu_server_data.mb_mappings[index]->tab_input_bits[i] = pi->Adr02[i];
      for ( i = 0; pi->N03 > i; ++i )
        rtu_server_data.mb_mappings[index]->tab_registers[i] = pi->Adr03[i];
      for ( i = 0; pi->N04 > i; ++i )
        rtu_server_data.mb_mappings[index]->tab_input_registers[i] = pi->Adr04[i];
      j_local_debug("init rtu slave register success\n");
      fflush(log_fp);
      if ( j_modbus_set_indication_timeout(ctx1, 0, 0x2710u) )
        pi->Err = 1;
      while ( 1 )
      {
        pi = rtu_server_data.pi[index];
        if ( g_prog_status == 3 || g_prog_status == 5 || !rtu_server_data.connected[index] && pi->DISCONNECT == 1 )
          break;
        rc = j_modbus_receive(ctx1, query);
        if ( rc != -1 )
        {
          if ( pi->Addr == query[header_length - 1] )
          {
            address = (query[header_length + 1] << 8) + query[header_length + 2];
            if ( query[header_length] == 6 )
            {
              data = (query[header_length + 3] << 8) + query[header_length + 4];
              j_local_debug("rtu slave write hode reg, %d--%d\n", address, data);
              fflush(log_fp);
              rtu_server_data.mb_mappings[index]->tab_registers[address] = data;
              pi->Adr03[address] = data;
            }
            if ( query[header_length] == 5 )
            {
              data = query[header_length + 3] & 1;
              j_local_debug("rtu slave write coils, %d---%d\n", address, data);
              fflush(log_fp);
              rtu_server_data.mb_mappings[index]->tab_bits[address] = data;
              pi->Adr01[address] = data;
            }
            if ( rc != -1 && j_modbus_reply(ctx1, query, rc, rtu_server_data.mb_mappings[index]) == -1 )
              pi->Err = 1;
          }
          else
          {
            j_local_debug("addr: %d, query id: %d\n", pi->Addr, query[header_length - 1]);
            fflush(log_fp);
            usleep(0xAu);
          }
        }
      }
      j_local_debug("rtu slave thread exit: %ld\n", tcp_server_data.tids[index]);
      fflush(log_fp);
      j_local_debug("rtu slave thread will exit\n");
      fflush(log_fp);
      j_modbus_close(ctx1);
      j_modbus_free(ctx1);
      j_modbus_mapping_free(rtu_server_data.mb_mappings[index]);
      rtu_server_data.connected[index] = 0;
      rtu_server_data.ctxs[index] = 0;
      rtu_server_data.pi[index] = 0;
      j_local_debug("rtu slave thread exited\n");
      fflush(log_fp);
      pthread_exit(0);
    }
    v6 = stderr;
    v7 = _errno_location();
    v8 = j_modbus_strerror(*v7);
    fprintf(v6, "Connection failed: %s\n", v8);
    j_modbus_free(ctx1);
    pi->Err = 1;
  }
  else
  {
    v3 = stderr;
    v4 = _errno_location();
    v5 = j_modbus_strerror(*v4);
    fprintf(v3, "Failed to allocate the mapping: %s\n", v5);
    pi->Err = 1;
  }
  return 0;
}

//----- (00004DD8) --------------------------------------------------------
int __cdecl modbus_rtu_server_init(mb_rtu_server_struct *pi, modbus_t **ctx, char *device)
{
  char parity; // [sp+1Fh] [bp+17h]

  j_local_debug("create modbus rtu to device: %s, %x\n", device, pi->Parity);
  fflush(log_fp);
  if ( pi->Parity )
  {
    if ( pi->Parity == 1 )
    {
      parity = 69;
    }
    else
    {
      if ( pi->Parity != 2 )
      {
        j_local_debug("error parity para\n");
        fflush(log_fp);
        return -1;
      }
      parity = 79;
    }
  }
  else
  {
    parity = 78;
  }
  j_local_debug("baud: %d\n", pi->Baud);
  fflush(log_fp);
  *ctx = j_modbus_new_rtu(device, pi->Baud, parity, 8, 1);
  if ( *ctx )
  {
    if ( j_modbus_set_slave(*ctx, pi->Addr) )
    {
      j_local_debug("error when modbus_set_slave\n");
      fflush(log_fp);
      j_modbus_close(*ctx);
      j_modbus_free(*ctx);
      return -1;
    }
    else
    {
      j_local_debug("modbus set slave %d\n", pi->Addr);
      fflush(log_fp);
      j_modbus_rtu_set_serial_mode(*ctx, 0);
      if ( j_modbus_rtu_set_rts_delay(*ctx, pi->Delay) )
      {
        j_local_debug("error when modbus_rtu_set_rts_delay\n");
        fflush(log_fp);
        j_modbus_close(*ctx);
        j_modbus_free(*ctx);
        return -1;
      }
      else
      {
        pi->INIDone = 1;
        j_local_debug("modbus rtu server init success\n");
        fflush(log_fp);
        return 0;
      }
    }
  }
  else
  {
    j_local_debug("rtu modbus create failed\n");
    fflush(log_fp);
    return -1;
  }
}

//----- (00004FBC) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __cdecl mb_rtu_server__main(mb_rtu_server_main_struct *p)
{
  int index; // [sp+8h] [bp+8h]
  mb_rtu_server_struct *pi; // [sp+Ch] [bp+Ch]

  pi = p->pInstance;
  if ( p->pInstance == (mb_rtu_server_struct *)-4 )
  {
    HIWORD(dword_74) = -1;
  }
  else
  {
    index = j_index_exchange(pi->Device);
    if ( index >= 0 )
    {
      rtu_server_data.pi[index] = pi;
      if ( pi->DISCONNECT || rtu_server_data.connected[index] )
      {
        if ( pi->DISCONNECT || !rtu_server_data.connected[index] )
        {
          if ( pi->DISCONNECT == 1 && rtu_server_data.connected[index] )
          {
            j_local_debug("rtu slave disconnect...\n");
            fflush(log_fp);
            rtu_server_data.connected[index] = 0;
            sleep(2u);
            j_local_debug("rtu slave disconnected\n");
            fflush(log_fp);
            pi->INIDone = 0;
            pi->Err = 0;
          }
          else if ( pi->DISCONNECT == 1 && !rtu_server_data.connected[index] )
          {
            pi->INIDone = 0;
          }
        }
        else
        {
          memcpy(rtu_server_data.mb_mappings[index]->tab_input_bits, pi->Adr02, pi->N02);
          memcpy(rtu_server_data.mb_mappings[index]->tab_input_registers, pi->Adr04, pi->N04);
          pi->Err = 0;
          pi->INIDone = 1;
        }
      }
      else
      {
        j_local_debug("rtu slave connect\n");
        fflush(log_fp);
        if ( j_modbus_rtu_server_init(pi, &rtu_server_data.ctxs[index], &RTU_DEVICE_NAME[32 * index]) )
        {
          pi->Err = 1;
        }
        else
        {
          rtu_server_data.connected[index] = 1;
          rtu_server_data.pi[index] = pi;
          if ( pthread_create(&rtu_server_data.tids[index], 0, (void *(*)(void *))rtu_server_func, pi) )
          {
            pi->Err = 1;
            j_local_debug("rtu slave thread create failed\n");
          }
          else
          {
            pi->Err = 0;
            j_local_debug("rtu slave thread create success\n");
          }
          fflush(log_fp);
          sleep(2u);
        }
      }
    }
    else
    {
      pi->Err = 1;
    }
  }
}
// 4FE0: write access to const memory at 76 has been detected
// 74: using guessed type int;

//----- (00005228) --------------------------------------------------------
int __cdecl modbus_tcp_client_init(mb_tcp_client_struct *pi, int port, modbus_t **ctx)
{
  char ip[20]; // [sp+20h] [bp+18h] BYREF

  memset(ip, 0, 0x10u);
  sprintf(ip, "%d.%d.%d.%d", pi->IP[0], pi->IP[1], pi->IP[2], pi->IP[3]);
  *ctx = j_modbus_new_tcp(ip, port);
  if ( !*ctx )
    return -1;
  j_modbus_set_slave(*ctx, pi->ID);
  j_modbus_set_response_timeout(*ctx, 0, 1000 * pi->TimeOut);
  return 0;
}

//----- (000052D0) --------------------------------------------------------
void *__cdecl __noreturn tcp_client_func(void *arg)
{
  int Part; // r5
  int *v2; // r0
  const char *v3; // r0
  modbus_t *ctx; // [sp+8h] [bp+8h] BYREF
  mb_tcp_client_struct *pi; // [sp+Ch] [bp+Ch]
  int port; // [sp+10h] [bp+10h]
  int curse; // [sp+14h] [bp+14h]
  int j; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  curse = *(_DWORD *)arg;
  i = 0;
  j = 0;
  port = 0;
  while ( 1 )
  {
    while ( g_prog_status != 1 )
      sleep(1u);
    for ( i = 0; tcp_client_data.curse > i; ++i )
    {
      pi = tcp_client_data.pi[i];
      if ( pi )
      {
        for ( j = 500; j < 510; ++j )
        {
          if ( tcp_client_data.port[i][j] )
          {
            if ( j_modbus_tcp_client_init(pi, j, &ctx) )
            {
              printf("tcp master modbus init failed: %d\n", pi->Part);
              pi->ERR = 1;
              usleep(0x64u);
            }
            else if ( j_modbus_connect(ctx) == -1 )
            {
              Part = pi->Part;
              v2 = _errno_location();
              v3 = j_modbus_strerror(*v2);
              printf("tcp master modbus_connect failed: %d-- %s\n", Part, v3);
              j_modbus_close(ctx);
              j_modbus_free(ctx);
              pi->ERR = 1;
              usleep(0x64u);
            }
            else
            {
              if ( j_modbus_read_input_bits(ctx, 0, tcp_client_data.length[i][j][1], tcp_client_data.adr2[i][j]) == -1 )
                pi->ERR = 1;
              if ( j_modbus_read_input_registers(ctx, 0, tcp_client_data.length[i][j][3], tcp_client_data.adr4[i][j]) == -1 )
                pi->ERR = 1;
              if ( j_modbus_write_bits(ctx, 0, tcp_client_data.length[i][j][0], tcp_client_data.adr1[i][j]) == -1 )
                pi->ERR = 1;
              if ( j_modbus_write_registers(ctx, 0, tcp_client_data.length[i][j][2], tcp_client_data.adr3[i][j]) == -1 )
                pi->ERR = 1;
              printf("tcp data[%d]\n", j);
              j_modbus_close(ctx);
              j_modbus_free(ctx);
            }
          }
        }
      }
      else
      {
        sleep(1u);
      }
    }
  }
}

//----- (000055A0) --------------------------------------------------------
void __cdecl mb_tcp_client__main(mb_tcp_client_main_struct *p)
{
  in_addr_t v1; // r0
  char str_ip[16]; // [sp+10h] [bp+8h] BYREF
  int ip; // [sp+20h] [bp+18h]
  mb_tcp_client_struct *pi; // [sp+24h] [bp+1Ch]
  int error; // [sp+28h] [bp+20h]
  int ip_cached; // [sp+2Ch] [bp+24h]
  int data_cached; // [sp+30h] [bp+28h]
  int index; // [sp+34h] [bp+2Ch]
  int j; // [sp+38h] [bp+30h]
  int i; // [sp+3Ch] [bp+34h]

  error = 0;
  i = 0;
  j = 0;
  index = 0;
  data_cached = 0;
  ip_cached = 0;
  pi = p->pInstance;
  if ( pi->DISCONNECT == 1 )
  {
    pi->ERR = 0;
    return;
  }
  memset(str_ip, 0, sizeof(str_ip));
  sprintf(str_ip, "%d.%d.%d.%d", pi->IP[0], pi->IP[1], pi->IP[2], pi->IP[3]);
  v1 = inet_addr(str_ip);
  ip = ntohl(v1);
  for ( i = 0; i <= 19; ++i )
  {
    if ( tcp_client_data.ip[i] == ip )
    {
      ip_cached = 1;
      index = i;
      for ( j = 0; j < 510; ++j )
      {
        if ( tcp_client_data.port[i][pi->Part] == 1 )
        {
          data_cached = 1;
          goto LABEL_13;
        }
      }
      break;
    }
  }
LABEL_13:
  if ( !data_cached )
  {
    if ( ip_cached )
    {
      tcp_client_data.ip[index] = ip;
      tcp_client_data.port[index][pi->Part] = 1;
      tcp_client_data.length[index][pi->Part][0] = pi->N01;
      tcp_client_data.length[index][pi->Part][1] = pi->N02;
      tcp_client_data.length[index][pi->Part][2] = pi->N03;
      tcp_client_data.length[index][pi->Part][3] = pi->N04;
    }
    else
    {
      tcp_client_data.pi[tcp_client_data.curse] = pi;
      tcp_client_data.ip[tcp_client_data.curse] = ip;
      tcp_client_data.port[tcp_client_data.curse][pi->Part] = 1;
      tcp_client_data.length[tcp_client_data.curse][pi->Part][0] = pi->N01;
      tcp_client_data.length[tcp_client_data.curse][pi->Part][1] = pi->N02;
      tcp_client_data.length[tcp_client_data.curse][pi->Part][2] = pi->N03;
      tcp_client_data.length[tcp_client_data.curse][pi->Part][3] = pi->N04;
    }
    ++tcp_client_data.curse;
    if ( !tcp_client_data.task_runing
      && pthread_create(
           &tcp_client_data.tids[tcp_client_data.curse],
           0,
           (void *(*)(void *))tcp_client_func,
           &tcp_client_data.curse) )
    {
      puts("tcp client create thread failed");
      return;
    }
    sleep(1u);
  }
  if ( pi->REQ )
  {
    if ( !pi->Done )
    {
      if ( pi->N02 )
        memcpy(pi->Adr02, tcp_client_data.adr2[index][pi->Part], pi->N02);
      if ( pi->N04 )
        memcpy(pi->Adr04, tcp_client_data.adr4[index][pi->Part], pi->N04);
      if ( pi->N01 )
        memcpy(tcp_client_data.adr1[index][pi->Part], pi->Adr01, pi->N01);
      if ( pi->N03 )
        memcpy(tcp_client_data.adr3[index][pi->Part], pi->Adr03, pi->N03);
      if ( !error )
      {
        pi->Done = 1;
        pi->ERR = 0;
      }
    }
  }
  else
  {
    pi->Done = 0;
  }
}

//----- (00005A2C) --------------------------------------------------------
void *__cdecl tcp_server_func(void *arg)
{
  pthread_t v1; // r0
  modbus_mapping_t **v2; // r5
  struct _IO_FILE *v3; // r4
  int *v4; // r0
  const char *v5; // r0
  int v6; // r3
  int v7; // r3
  int v8; // r3
  char *v9; // r0
  int v10; // r3
  uint8_t query[260]; // [sp+10h] [bp+8h] BYREF
  sockaddr_in clientaddr; // [sp+114h] [bp+10Ch] BYREF
  socklen_t addrlen; // [sp+124h] [bp+11Ch] BYREF
  timeval tv; // [sp+128h] [bp+120h] BYREF
  fd_set rdset; // [sp+130h] [bp+128h] BYREF
  fd_set refset; // [sp+1B0h] [bp+1A8h] BYREF
  int data; // [sp+230h] [bp+228h]
  int address; // [sp+234h] [bp+22Ch]
  int newfd; // [sp+238h] [bp+230h]
  int rc; // [sp+23Ch] [bp+234h]
  fd_set *__arr; // [sp+240h] [bp+238h]
  int server_socket; // [sp+244h] [bp+23Ch]
  int header_length; // [sp+248h] [bp+240h]
  modbus_t *ctx1; // [sp+24Ch] [bp+244h]
  pthread_t self_id; // [sp+250h] [bp+248h]
  unsigned int __i; // [sp+254h] [bp+24Ch]
  int fdmax; // [sp+258h] [bp+250h]
  int master_socket; // [sp+25Ch] [bp+254h]
  int i; // [sp+260h] [bp+258h]
  mb_tcp_server_struct *pi; // [sp+264h] [bp+25Ch]
  _DWORD vars0[4]; // [sp+268h] [bp+260h] BYREF

  v1 = pthread_self();
  pthread_detach(v1);
  self_id = pthread_self();
  for ( i = 0; i < 510 && tcp_server_data.tids[i] != self_id; ++i )
    ;
  pi = tcp_server_data.pi[i];
  ctx1 = tcp_server_data.tcp_server_ctxs[pi->Part];
  header_length = j_modbus_get_header_length(ctx1);
  v2 = &tcp_server_data.mb_mappings[pi->Part];
  *v2 = j_modbus_mapping_new(2000, 1968, 125, 123);
  if ( tcp_server_data.mb_mappings[pi->Part] )
  {
    j_local_debug("tcp slave mapping success\n");
    fflush(log_fp);
    for ( i = 0; pi->N01 > i; ++i )
      tcp_server_data.mb_mappings[pi->Part]->tab_bits[i] = pi->Adr01[i];
    for ( i = 0; pi->N02 > i; ++i )
      tcp_server_data.mb_mappings[pi->Part]->tab_input_bits[i] = pi->Adr02[i];
    for ( i = 0; pi->N03 > i; ++i )
      tcp_server_data.mb_mappings[pi->Part]->tab_registers[i] = pi->Adr03[i];
    for ( i = 0; pi->N04 > i; ++i )
      tcp_server_data.mb_mappings[pi->Part]->tab_input_registers[i] = pi->Adr04[i];
    server_socket = j_modbus_tcp_listen(ctx1, 10);
    __arr = &refset;
    for ( __i = 0; __i <= 0x1F; ++__i )
      __arr->__fds_bits[__i] = 0;
    LOBYTE(v6) = server_socket & 0x1F;
    if ( server_socket <= 0 )
      v6 = -(-server_socket & 0x1F);
    vars0[server_socket / 32 - 46] |= 1 << v6;
    fdmax = server_socket;
    tv.tv_sec = 0;
    tv.tv_usec = 100000;
    while ( g_prog_status != 3 && g_prog_status != 5 && (tcp_server_data.connected[pi->Part] || pi->DISCONNECT != 1) )
    {
      memcpy(&rdset, &refset, sizeof(rdset));
      tv.tv_sec = 0;
      tv.tv_usec = 100000;
      rc = select(fdmax + 1, &rdset, 0, 0, &tv);
      if ( rc )
      {
        if ( rc == -1 )
        {
          perror("Server select() failure.");
          close(server_socket);
          j_modbus_close(ctx1);
          j_modbus_free(ctx1);
          j_modbus_mapping_free(tcp_server_data.mb_mappings[pi->Part]);
          tcp_server_data.connected[pi->Part] = 0;
          pi->DISCONNECT = 1;
          pi->ERR = 1;
          pthread_exit(0);
        }
        if ( pi->Part || tcp_server_data.connected[pi->Part] )
        {
          for ( master_socket = 0; master_socket <= fdmax; ++master_socket )
          {
            LOBYTE(v7) = master_socket & 0x1F;
            if ( master_socket <= 0 )
              v7 = -(-master_socket & 0x1F);
            if ( ((1 << v7) & rdset.__fds_bits[master_socket / 32]) != 0 )
            {
              if ( master_socket == server_socket )
              {
                addrlen = 16;
                memset(&clientaddr, 0, sizeof(clientaddr));
                newfd = accept(server_socket, (struct sockaddr *)&clientaddr, &addrlen);
                if ( newfd == -1 )
                {
                  perror("Server accept() error");
                }
                else
                {
                  LOBYTE(v8) = newfd & 0x1F;
                  if ( newfd <= 0 )
                    v8 = -(-newfd & 0x1F);
                  vars0[newfd / 32 - 46] |= 1 << v8;
                  if ( newfd > fdmax )
                    fdmax = newfd;
                  v9 = inet_ntoa(clientaddr.sin_addr);
                  j_local_debug("New connection from %s:%d on socket %d\n", v9, clientaddr.sin_port, newfd);
                  fflush(log_fp);
                }
              }
              else
              {
                j_modbus_set_socket(ctx1, master_socket);
                rc = j_modbus_receive(ctx1, query);
                if ( rc != -1 )
                {
                  address = (query[header_length + 1] << 8) + query[header_length + 2];
                  if ( query[header_length] == 6 )
                  {
                    data = (query[header_length + 3] << 8) + query[header_length + 4];
                    tcp_server_data.mb_mappings[pi->Part]->tab_registers[address] = data;
                    pi->Adr03[address] = data;
                  }
                  if ( query[header_length] == 5 )
                  {
                    data = query[header_length + 3] & 1;
                    tcp_server_data.mb_mappings[pi->Part]->tab_bits[address] = data;
                    pi->Adr01[address] = data;
                  }
                  if ( rc == -1 )
                  {
                    j_local_debug("Connection closed on socket %d\n", master_socket);
                    fflush(log_fp);
                    close(master_socket);
                    LOBYTE(v10) = master_socket & 0x1F;
                    if ( master_socket <= 0 )
                      v10 = -(-master_socket & 0x1F);
                    vars0[master_socket / 32 - 46] &= ~(1 << v10);
                    if ( master_socket == fdmax )
                      --fdmax;
                  }
                  else if ( j_modbus_reply(ctx1, query, rc, tcp_server_data.mb_mappings[pi->Part]) == -1 )
                  {
                    pi->ERR = 0;
                  }
                }
              }
            }
          }
        }
        else
        {
          for ( i = 0; i < 510 && tcp_server_data.tids[i] != self_id; ++i )
            ;
          pi = tcp_server_data.pi[i];
          usleep(0xAu);
        }
      }
    }
    j_local_debug("tcp slave thread exit: %ld\n", tcp_server_data.tids[pi->Part]);
    fflush(log_fp);
    j_local_debug("tcp slave exit...\n");
    fflush(log_fp);
    close(server_socket);
    j_modbus_close(ctx1);
    j_modbus_free(ctx1);
    j_modbus_mapping_free(tcp_server_data.mb_mappings[pi->Part]);
    j_local_debug("connected: %d\n", tcp_server_data.connected[pi->Part]);
    fflush(log_fp);
    tcp_server_data.connected[pi->Part] = 0;
    tcp_server_data.pi[pi->Part] = 0;
    j_local_debug("connected: %d\n", tcp_server_data.connected[pi->Part]);
    fflush(log_fp);
    j_local_debug("tcp slave exited\n");
    fflush(log_fp);
    pthread_exit(0);
  }
  v3 = stderr;
  v4 = _errno_location();
  v5 = j_modbus_strerror(*v4);
  fprintf(v3, "Failed to allocate the mapping: %s\n", v5);
  j_modbus_free(ctx1);
  return 0;
}

//----- (00006340) --------------------------------------------------------
int __cdecl get_localip(const char *eth_name, char *local_ip_addr)
{
  int v3; // r0
  int v4; // r5
  unsigned int v5; // r4
  char *v6; // r0
  int v7; // r3
  ifconf ifc; // [sp+Ch] [bp+Ch] BYREF
  ifreq ifr[32]; // [sp+14h] [bp+14h] BYREF
  int ret; // [sp+414h] [bp+414h]

  ret = -1;
  if ( !local_ip_addr || !eth_name )
    return ret;
  v3 = socket(2, 2, 0);
  v4 = v3;
  if ( v3 > 0 )
  {
    ifc.ifc_len = 1024;
    ifc.ifc_ifcu.ifcu_buf = (__caddr_t)ifr;
    if ( !ioctl(v3, 0x8912u, &ifc) )
    {
      v5 = (unsigned int)ifc.ifc_len >> 5;
      while ( 1 )
      {
        v7 = v5--;
        if ( v7 <= 0 )
          break;
        if ( !ioctl(v4, 0x8915u, &ifr[v5]) && !strcmp(eth_name, ifr[v5].ifr_ifrn.ifrn_name) )
        {
          ret = 0;
          v6 = inet_ntoa(*(struct in_addr *)&ifr[v5].ifr_ifru.ifru_netmask.sa_data[2]);
          strcpy(local_ip_addr, v6);
          break;
        }
      }
    }
  }
  if ( v4 > 0 )
    close(v4);
  return ret;
}

//----- (0000642A) --------------------------------------------------------
int __cdecl modbus_tcp_server_init(mb_tcp_server_struct *pi, modbus_t **ctx)
{
  char netcard_name[12]; // [sp+Ch] [bp+Ch] BYREF
  char ip[20]; // [sp+18h] [bp+18h] BYREF

  memset(ip, 0, sizeof(ip));
  sprintf(netcard_name, "eth%d", pi->Eth);
  if ( j_get_localip(netcard_name, ip) )
  {
    j_local_debug("get local ip failure\n");
    fflush(log_fp);
    return -1;
  }
  else
  {
    j_local_debug("local ip:%s\n", ip);
    fflush(log_fp);
    *ctx = j_modbus_new_tcp(ip, pi->Part);
    if ( *ctx )
      return 0;
    else
      return -1;
  }
}

//----- (000064F0) --------------------------------------------------------
void __cdecl mb_tcp_server__main(mb_tcp_server_main_struct *p)
{
  mb_tcp_server_struct *pi; // [sp+Ch] [bp+Ch]

  pi = p->pInstance;
  tcp_server_data.pi[pi->Part] = p->pInstance;
  if ( pi->DISCONNECT || tcp_server_data.connected[pi->Part] )
  {
    if ( pi->DISCONNECT || !tcp_server_data.connected[pi->Part] )
    {
      if ( pi->DISCONNECT == 1 && tcp_server_data.connected[pi->Part] )
      {
        j_local_debug("tcp slave disconnect...\n");
        fflush(log_fp);
        tcp_server_data.connected[pi->Part] = 0;
        pi->ERR = 0;
        j_local_debug("tcp slave disconnected\n");
        fflush(log_fp);
      }
    }
    else
    {
      memcpy(tcp_server_data.mb_mappings[pi->Part]->tab_input_bits, pi->Adr02, pi->N02);
      memcpy(tcp_server_data.mb_mappings[pi->Part]->tab_input_registers, pi->Adr04, pi->N04);
      pi->ERR = 0;
    }
  }
  else
  {
    j_local_debug("init tcp slave\n");
    fflush(log_fp);
    if ( j_modbus_tcp_server_init(pi, &tcp_server_data.tcp_server_ctxs[pi->Part]) )
    {
      pi->ERR = 1;
    }
    else
    {
      tcp_server_data.connected[pi->Part] = 1;
      tcp_server_data.pi[pi->Part] = p->pInstance;
      if ( pthread_create(&tcp_server_data.tids[pi->Part], 0, (void *(*)(void *))tcp_server_func, pi) )
      {
        pi->ERR = 1;
        j_local_debug("tcp slave create thread failed\n");
      }
      else
      {
        j_local_debug("tcp slave create thread success\n");
      }
      fflush(log_fp);
      sleep(2u);
    }
  }
}

//----- (00006708) --------------------------------------------------------
void __cdecl modbus_set_bits_from_byte(uint8_t *dest, int idx, const uint8_t value)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    dest[i + idx] = (((int)value >> i) & 1) != 0;
}

//----- (00006758) --------------------------------------------------------
void __cdecl modbus_set_bits_from_bytes(uint8_t *dest, int idx, unsigned int nb_bits, const uint8_t *tab_byte)
{
  int v4; // r3
  int shift; // [sp+10h] [bp+10h]
  int shifta; // [sp+10h] [bp+10h]
  unsigned int i; // [sp+14h] [bp+14h]

  shift = 0;
  for ( i = idx; idx + nb_bits > i; ++i )
  {
    dest[i] = (((int)tab_byte[(i - idx) >> 3] >> shift) & 1) != 0;
    shifta = shift + 1;
    v4 = shifta & 7;
    if ( shifta <= 0 )
      v4 = -(-shifta & 7);
    shift = v4;
  }
}

//----- (000067D2) --------------------------------------------------------
uint8_t __cdecl modbus_get_byte_from_bits(const uint8_t *src, int idx, unsigned int nb_bits)
{
  uint8_t value; // [sp+13h] [bp+13h]
  unsigned int i; // [sp+14h] [bp+14h]

  value = 0;
  if ( nb_bits > 8 )
    _assert_fail("nb_bits < 8", "../modbus-data.c", 0x6Eu, "modbus_get_byte_from_bits");
  for ( i = 0; i < nb_bits; ++i )
    value |= src[i + idx] << i;
  return value;
}
// 67EC: conditional instruction was optimized away because r2.4>=9u

//----- (00006850) --------------------------------------------------------
float __cdecl modbus_get_float_abcd(const uint16_t *src)
{
  return COERCE_FLOAT(ntohl((*src << 16) + src[1]));
}

//----- (00006884) --------------------------------------------------------
float __cdecl modbus_get_float_dcba(const uint16_t *src)
{
  return COERCE_FLOAT(ntohl(bswap32((*src << 16) + src[1])));
}

//----- (000068BA) --------------------------------------------------------
float __cdecl modbus_get_float_badc(const uint16_t *src)
{
  return COERCE_FLOAT(ntohl((unsigned __int16)__rev16(src[1]) + ((unsigned __int16)__rev16(*src) << 16)));
}

//----- (000068F8) --------------------------------------------------------
float __cdecl modbus_get_float_cdab(const uint16_t *src)
{
  return COERCE_FLOAT(ntohl((src[1] << 16) + *src));
}

//----- (0000692C) --------------------------------------------------------
float __cdecl modbus_get_float(const uint16_t *src)
{
  float result; // r0

  LODWORD(result) = src;
  return result;
}

//----- (0000695C) --------------------------------------------------------
void __cdecl modbus_set_float_abcd(float f, uint16_t *dest)
{
  uint32_t v2; // s0
  uint32_t v3; // r0

  v3 = htonl(v2);
  *(_WORD *)LODWORD(f) = HIWORD(v3);
  *(_WORD *)(LODWORD(f) + 2) = v3;
}
// 6970: variable 'v2' is possibly undefined

//----- (00006994) --------------------------------------------------------
void __cdecl modbus_set_float_dcba(float f, uint16_t *dest)
{
  uint32_t v2; // s0
  uint32_t i; // [sp+Ch] [bp+Ch]

  i = bswap32(htonl(v2));
  *(_WORD *)LODWORD(f) = HIWORD(i);
  *(_WORD *)(LODWORD(f) + 2) = i;
}
// 69A8: variable 'v2' is possibly undefined

//----- (000069CE) --------------------------------------------------------
void __cdecl modbus_set_float_badc(float f, uint16_t *dest)
{
  uint32_t v2; // s0
  uint32_t v3; // r0

  v3 = htonl(v2);
  *(_WORD *)LODWORD(f) = __rev16(HIWORD(v3));
  *(_WORD *)(LODWORD(f) + 2) = __rev16((unsigned __int16)v3);
}
// 69E2: variable 'v2' is possibly undefined

//----- (00006A0E) --------------------------------------------------------
void __cdecl modbus_set_float_cdab(float f, uint16_t *dest)
{
  uint32_t v2; // s0

  *(_DWORD *)LODWORD(f) = htonl(v2);
}
// 6A22: variable 'v2' is possibly undefined

//----- (00006A46) --------------------------------------------------------
void __cdecl modbus_set_float(float f, uint16_t *dest)
{
  int v2; // s0

  *(_DWORD *)LODWORD(f) = v2;
}
// 6A5C: variable 'v2' is possibly undefined

//----- (00006A78) --------------------------------------------------------
int __cdecl modbus_set_slave(modbus_t *ctx, int slave)
{
  if ( (unsigned int)slave >= 0xF8 )
  {
    *_errno_location() = 22;
    return -1;
  }
  else
  {
    ctx->slave = slave;
    return 0;
  }
}

//----- (00006AAE) --------------------------------------------------------
int __cdecl modbus_rtu_build_request_basis(modbus_t *ctx, int function, int addr, int nb, uint8_t *req)
{
  if ( ctx->slave == -1 )
    _assert_fail("ctx->slave != -1", "../modbus-rtu.c", 0x6Eu, "_modbus_rtu_build_request_basis");
  *req = ctx->slave;
  req[1] = function;
  req[2] = BYTE1(addr);
  req[3] = addr;
  req[4] = BYTE1(nb);
  req[5] = nb;
  return 6;
}

//----- (00006B30) --------------------------------------------------------
int __cdecl modbus_rtu_build_response_basis(sft_t *sft, uint8_t *rsp)
{
  *rsp = sft->slave;
  rsp[1] = sft->function;
  return 2;
}

//----- (00006B5E) --------------------------------------------------------
uint16_t __cdecl crc16(uint8_t *buffer, uint16_t buffer_length)
{
  uint8_t *v2; // r3
  unsigned int i; // [sp+8h] [bp+8h]
  uint8_t crc_lo; // [sp+Eh] [bp+Eh]
  uint8_t crc_hi; // [sp+Fh] [bp+Fh]

  crc_hi = -1;
  for ( crc_lo = -1; buffer_length--; crc_lo = table_crc_lo[i] )
  {
    v2 = buffer++;
    i = (unsigned __int8)(crc_hi ^ *v2);
    crc_hi = crc_lo ^ table_crc_hi[i];
  }
  return crc_lo | (crc_hi << 8);
}

//----- (00006BD4) --------------------------------------------------------
int __cdecl modbus_rtu_prepare_response_tid(const uint8_t *req, int *req_length)
{
  *req_length -= 2;
  return 0;
}

//----- (00006BF6) --------------------------------------------------------
int __cdecl modbus_rtu_send_msg_pre(uint8_t *req, int req_length)
{
  uint16_t v2; // r0

  v2 = crc16(req, req_length);
  req[req_length] = HIBYTE(v2);
  req[req_length + 1] = v2;
  return req_length + 2;
}

//----- (00006C42) --------------------------------------------------------
void __cdecl modbus_rtu_ioctl_rts(modbus_t *ctx, int on)
{
  int flags; // [sp+8h] [bp+8h] BYREF
  int fd; // [sp+Ch] [bp+Ch]

  fd = ctx->s;
  ioctl(fd, 0x5415u, &flags);
  if ( on )
    flags |= 4u;
  else
    flags &= ~4u;
  ioctl(fd, 0x5418u, &flags);
}

//----- (00006C92) --------------------------------------------------------
ssize_t __cdecl modbus_rtu_send(modbus_t *ctx, const uint8_t *req, int req_length)
{
  ssize_t size; // [sp+10h] [bp+10h]
  modbus_rtu_t *ctx_rtu; // [sp+14h] [bp+14h]

  ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if ( !ctx_rtu->rts )
    return write(ctx->s, req, req_length);
  if ( ctx->debug )
    fwrite("Sending request using RTS signal\n", 1u, 0x21u, stderr);
  ctx_rtu->set_rts(ctx, ctx_rtu->rts == 1);
  usleep(ctx_rtu->rts_delay);
  size = write(ctx->s, req, req_length);
  usleep(ctx_rtu->rts_delay + req_length * ctx_rtu->onebyte_time);
  ctx_rtu->set_rts(ctx, ctx_rtu->rts != 1);
  return size;
}

//----- (00006D54) --------------------------------------------------------
int __cdecl modbus_rtu_receive(modbus_t *ctx, uint8_t *req)
{
  modbus_rtu_t *ctx_rtu; // [sp+8h] [bp+8h]
  int rc; // [sp+Ch] [bp+Ch]

  ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if ( ctx_rtu->confirmation_to_ignore )
  {
    j__modbus_receive_msg(ctx, req, MSG_CONFIRMATION);
    ctx_rtu->confirmation_to_ignore = 0;
    rc = 0;
    if ( ctx->debug )
      puts("Confirmation to ignore");
  }
  else
  {
    rc = j__modbus_receive_msg(ctx, req, MSG_INDICATION);
    if ( !rc )
      ctx_rtu->confirmation_to_ignore = 1;
  }
  return rc;
}

//----- (00006DBC) --------------------------------------------------------
ssize_t __cdecl modbus_rtu_recv(modbus_t *ctx, uint8_t *rsp, int rsp_length)
{
  return read(ctx->s, rsp, rsp_length);
}

//----- (00006DE0) --------------------------------------------------------
int __cdecl modbus_rtu_pre_check_confirmation(modbus_t *ctx, const uint8_t *req, const uint8_t *rsp, int rsp_length)
{
  if ( *req == *rsp || !*req )
    return 0;
  if ( ctx->debug )
    fprintf(stderr, "The responding slave %d isn't the requested slave %d\n", *rsp, *req);
  *_errno_location() = 112345695;
  return -1;
}

//----- (00006E54) --------------------------------------------------------
int __cdecl modbus_rtu_check_integrity(modbus_t *ctx, uint8_t *msg, const int msg_length)
{
  uint16_t crc_received; // [sp+10h] [bp+10h]
  uint16_t crc_calculated; // [sp+12h] [bp+12h]
  int slave; // [sp+14h] [bp+14h]

  slave = *msg;
  if ( ctx->slave == slave || !*msg )
  {
    crc_calculated = crc16(msg, msg_length - 2);
    crc_received = msg[msg_length - 1] | (msg[msg_length - 2] << 8);
    if ( crc_calculated == crc_received )
    {
      return msg_length;
    }
    else
    {
      if ( ctx->debug )
        fprintf(stderr, "ERROR CRC received 0x%0X != CRC calculated 0x%0X\n", crc_received, crc_calculated);
      if ( (ctx->error_recovery & 4) != 0 )
        modbus_rtu_flush(ctx);
      *_errno_location() = 112345690;
      return -1;
    }
  }
  else
  {
    if ( ctx->debug )
      printf("Request for slave %d ignored (not %d)\n", slave, ctx->slave);
    return 0;
  }
}

//----- (00006F30) --------------------------------------------------------
int __cdecl modbus_rtu_connect(modbus_t *ctx)
{
  struct _IO_FILE *v1; // r4
  char *device; // r5
  int *v3; // r0
  char *v4; // r0
  int baud; // r3
  int data_bit; // r3
  termios tios; // [sp+10h] [bp+8h] BYREF
  int flags; // [sp+4Ch] [bp+44h]
  modbus_rtu_t *ctx_rtu; // [sp+50h] [bp+48h]
  speed_t speed; // [sp+54h] [bp+4Ch]

  ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if ( ctx->debug )
    printf(
      "Opening %s at %d bauds (%c, %d, %d)\n",
      ctx_rtu->device,
      ctx_rtu->baud,
      (unsigned __int8)ctx_rtu->parity,
      ctx_rtu->data_bit,
      ctx_rtu->stop_bit);
  flags = 526722;
  ctx->s = open(ctx_rtu->device, 526722);
  if ( ctx->s == -1 )
  {
    if ( ctx->debug )
    {
      v1 = stderr;
      device = ctx_rtu->device;
      v3 = _errno_location();
      v4 = strerror(*v3);
      fprintf(v1, "ERROR Can't open the device %s (%s)\n", device, v4);
    }
    return -1;
  }
  tcgetattr(ctx->s, &ctx_rtu->old_tios);
  memset(&tios, 0, sizeof(tios));
  baud = ctx_rtu->baud;
  if ( baud == 230400 )
  {
    speed = 4099;
    goto LABEL_70;
  }
  if ( baud > 230400 )
  {
    if ( baud == 1152000 )
    {
      speed = 4105;
      goto LABEL_70;
    }
    if ( baud > 1152000 )
    {
      if ( baud == 3000000 )
      {
        speed = 4109;
        goto LABEL_70;
      }
      if ( baud > 3000000 )
      {
        if ( baud == 3500000 )
        {
          speed = 4110;
          goto LABEL_70;
        }
        if ( baud == 4000000 )
        {
          speed = 4111;
          goto LABEL_70;
        }
      }
      else
      {
        if ( baud == 1500000 )
        {
          speed = 4106;
          goto LABEL_70;
        }
        if ( baud == 2500000 )
        {
          speed = 4108;
          goto LABEL_70;
        }
      }
    }
    else
    {
      if ( baud == 576000 )
      {
        speed = 4102;
        goto LABEL_70;
      }
      if ( baud > 576000 )
      {
        if ( baud == 921600 )
        {
          speed = 4103;
          goto LABEL_70;
        }
        if ( baud == 1000000 )
        {
          speed = 4104;
          goto LABEL_70;
        }
      }
      else
      {
        if ( baud == 460800 )
        {
          speed = 4100;
          goto LABEL_70;
        }
        if ( baud == 500000 )
        {
          speed = 4101;
          goto LABEL_70;
        }
      }
    }
LABEL_68:
    speed = 13;
    if ( ctx->debug )
      fprintf(stderr, "WARNING Unknown baud rate %d for %s (B9600 used)\n", ctx_rtu->baud, ctx_rtu->device);
    goto LABEL_70;
  }
  if ( baud == 4800 )
  {
    speed = 12;
    goto LABEL_70;
  }
  if ( baud > 4800 )
  {
    if ( baud == 38400 )
    {
      speed = 15;
      goto LABEL_70;
    }
    if ( baud > 38400 )
    {
      if ( baud == 57600 )
      {
        speed = 4097;
        goto LABEL_70;
      }
      if ( baud == 115200 )
      {
        speed = 4098;
        goto LABEL_70;
      }
    }
    else
    {
      if ( baud == 9600 )
      {
        speed = 13;
        goto LABEL_70;
      }
      if ( baud == 19200 )
      {
        speed = 14;
        goto LABEL_70;
      }
    }
    goto LABEL_68;
  }
  if ( baud == 600 )
  {
    speed = 8;
    goto LABEL_70;
  }
  if ( baud > 600 )
  {
    if ( baud == 1200 )
    {
      speed = 9;
      goto LABEL_70;
    }
    if ( baud == 2400 )
    {
      speed = 11;
      goto LABEL_70;
    }
    goto LABEL_68;
  }
  if ( baud == 110 )
  {
    speed = 3;
  }
  else
  {
    if ( baud != 300 )
      goto LABEL_68;
    speed = 7;
  }
LABEL_70:
  if ( cfsetispeed(&tios, speed) < 0 || cfsetospeed(&tios, speed) < 0 )
    goto LABEL_92;
  tios.c_cflag |= 0x880u;
  tios.c_cflag &= 0xFFFFFFCF;
  data_bit = ctx_rtu->data_bit;
  if ( data_bit == 6 )
  {
    tios.c_cflag |= 0x10u;
  }
  else if ( data_bit == 7 )
  {
    tios.c_cflag |= 0x20u;
  }
  else if ( data_bit != 5 )
  {
    tios.c_cflag |= 0x30u;
  }
  if ( ctx_rtu->stop_bit == 1 )
    tios.c_cflag &= ~0x40u;
  else
    tios.c_cflag |= 0x40u;
  if ( ctx_rtu->parity == 78 )
  {
    tios.c_cflag &= ~0x100u;
  }
  else if ( ctx_rtu->parity == 69 )
  {
    tios.c_cflag |= 0x100u;
    tios.c_cflag &= ~0x200u;
  }
  else
  {
    tios.c_cflag |= 0x100u;
    tios.c_cflag |= 0x200u;
  }
  tios.c_lflag &= 0xFFFFFFE4;
  if ( ctx_rtu->parity == 78 )
    tios.c_iflag &= ~0x10u;
  else
    tios.c_iflag |= 0x10u;
  tios.c_iflag &= 0xFFFFE3FF;
  tios.c_oflag &= ~1u;
  tios.c_cc[6] = 0;
  tios.c_cc[5] = 0;
  if ( tcsetattr(ctx->s, 0, &tios) >= 0 )
    return 0;
LABEL_92:
  close(ctx->s);
  ctx->s = -1;
  return -1;
}

//----- (00007324) --------------------------------------------------------
int __cdecl modbus_rtu_set_serial_mode(modbus_t *ctx, int mode)
{
  serial_rs485 rs485conf; // [sp+Ch] [bp+Ch] BYREF
  modbus_rtu_t *ctx_rtu; // [sp+2Ch] [bp+2Ch]

  if ( !ctx || ctx->backend->backend_type )
    goto LABEL_16;
  ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if ( mode != 1 )
  {
    if ( !mode )
    {
      if ( ctx_rtu->serial_mode == 1 )
      {
        if ( ioctl(ctx->s, 0x542Eu, &rs485conf) < 0 )
          return -1;
        rs485conf.flags &= ~1u;
        if ( ioctl(ctx->s, 0x542Fu, &rs485conf) < 0 )
          return -1;
      }
      ctx_rtu->serial_mode = 0;
      return 0;
    }
LABEL_16:
    *_errno_location() = 22;
    return -1;
  }
  if ( ioctl(ctx->s, 0x542Eu, &rs485conf) < 0 )
    return -1;
  rs485conf.flags |= 1u;
  if ( ioctl(ctx->s, 0x542Fu, &rs485conf) < 0 )
    return -1;
  ctx_rtu->serial_mode = 1;
  return 0;
}

//----- (0000741A) --------------------------------------------------------
int __cdecl modbus_rtu_get_serial_mode(modbus_t *ctx)
{
  if ( ctx && !ctx->backend->backend_type )
    return *((_DWORD *)ctx->backend_data + 18);
  *_errno_location() = 22;
  return -1;
}

//----- (00007464) --------------------------------------------------------
int __cdecl modbus_rtu_get_rts(modbus_t *ctx)
{
  if ( ctx && !ctx->backend->backend_type )
    return *((_DWORD *)ctx->backend_data + 19);
  *_errno_location() = 22;
  return -1;
}

//----- (000074AE) --------------------------------------------------------
int __cdecl modbus_rtu_set_rts(modbus_t *ctx, int mode)
{
  modbus_rtu_t *ctx_rtu; // [sp+Ch] [bp+Ch]

  if ( !ctx || ctx->backend->backend_type || (ctx_rtu = (modbus_rtu_t *)ctx->backend_data, (unsigned int)mode > 2) )
  {
    *_errno_location() = 22;
    return -1;
  }
  else
  {
    ctx_rtu->rts = mode;
    ctx_rtu->set_rts(ctx, ctx_rtu->rts != 1);
    return 0;
  }
}

//----- (00007538) --------------------------------------------------------
int __cdecl modbus_rtu_set_custom_rts(modbus_t *ctx, void (*set_rts)(modbus_t *, int))
{
  if ( !ctx || ctx->backend->backend_type )
  {
    *_errno_location() = 22;
    return -1;
  }
  else
  {
    *((_DWORD *)ctx->backend_data + 22) = set_rts;
    return 0;
  }
}

//----- (00007588) --------------------------------------------------------
int __cdecl modbus_rtu_get_rts_delay(modbus_t *ctx)
{
  if ( ctx && !ctx->backend->backend_type )
    return *((_DWORD *)ctx->backend_data + 20);
  *_errno_location() = 22;
  return -1;
}

//----- (000075D2) --------------------------------------------------------
int __cdecl modbus_rtu_set_rts_delay(modbus_t *ctx, int us)
{
  if ( !ctx || us < 0 || ctx->backend->backend_type )
  {
    *_errno_location() = 22;
    return -1;
  }
  else
  {
    *((_DWORD *)ctx->backend_data + 20) = us;
    return 0;
  }
}

//----- (00007628) --------------------------------------------------------
void __cdecl modbus_rtu_close(modbus_t *ctx)
{
  if ( ctx->s != -1 )
  {
    tcsetattr(ctx->s, 0, (const struct termios *)((char *)ctx->backend_data + 12));
    close(ctx->s);
    ctx->s = -1;
  }
}

//----- (0000766A) --------------------------------------------------------
int __cdecl modbus_rtu_flush(modbus_t *ctx)
{
  return tcflush(ctx->s, 2);
}

//----- (00007688) --------------------------------------------------------
int __cdecl modbus_rtu_select(modbus_t *ctx, fd_set *rset, timeval *tv, int length_to_read)
{
  int i; // r0
  bool v5; // nf
  int v6; // r0
  int s; // r3
  int v8; // r0
  unsigned int __i; // [sp+24h] [bp+1Ch]

  for ( i = select(ctx->s + 1, rset, 0, 0, tv); i == -1; i = select(ctx->s + 1, rset, 0, 0, tv) )
  {
    if ( *_errno_location() != 4 )
      return -1;
    if ( ctx->debug )
      fwrite("A non blocked signal was caught\n", 1u, 0x20u, stderr);
    for ( __i = 0; __i <= 0x1F; ++__i )
      rset->__fds_bits[__i] = 0;
    s = ctx->s;
    v6 = -s;
    v5 = -s < 0;
    LOBYTE(s) = s & 0x1F;
    v8 = v6 & 0x1F;
    if ( !v5 )
      s = -v8;
    rset->__fds_bits[ctx->s / 32] |= 1 << s;
  }
  if ( i )
    return i;
  *_errno_location() = 110;
  return -1;
}

//----- (00007770) --------------------------------------------------------
void __cdecl modbus_rtu_free(modbus_t *ctx)
{
  if ( ctx->backend_data )
  {
    free(*(void **)ctx->backend_data);
    free(ctx->backend_data);
  }
  free(ctx);
}

//----- (000077A4) --------------------------------------------------------
modbus_t *__cdecl modbus_new_rtu(const char *device, int baud, char parity, int data_bit, int stop_bit)
{
  size_t v6; // r0
  modbus_rtu_t *ctx_rtu; // [sp+10h] [bp+10h]
  modbus_t *ctx; // [sp+14h] [bp+14h]

  if ( device && *device )
  {
    if ( baud )
    {
      ctx = (modbus_t *)malloc(0x30u);
      if ( ctx )
      {
        j__modbus_init_common(ctx);
        ctx->backend = &modbus_rtu_backend;
        ctx->backend_data = malloc(0x60u);
        if ( ctx->backend_data
          && (ctx_rtu = (modbus_rtu_t *)ctx->backend_data,
              v6 = strlen(device),
              (ctx_rtu->device = (char *)malloc(v6 + 1)) != 0) )
        {
          strcpy(ctx_rtu->device, device);
          ctx_rtu->baud = baud;
          if ( parity == 78 || parity == 69 || parity == 79 )
          {
            ctx_rtu->parity = parity;
            ctx_rtu->data_bit = data_bit;
            ctx_rtu->stop_bit = stop_bit;
            ctx_rtu->serial_mode = 0;
            ctx_rtu->rts = 0;
            ctx_rtu->onebyte_time = 1000000 * ((parity != 78) + data_bit + 1 + stop_bit) / baud;
            ctx_rtu->set_rts = (void (*)(modbus_t *, int))modbus_rtu_ioctl_rts;
            ctx_rtu->rts_delay = ctx_rtu->onebyte_time;
            ctx_rtu->confirmation_to_ignore = 0;
            return ctx;
          }
          else
          {
            j_modbus_free(ctx);
            *_errno_location() = 22;
            return 0;
          }
        }
        else
        {
          j_modbus_free(ctx);
          *_errno_location() = 12;
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      fwrite("The baud rate value must not be zero\n", 1u, 0x25u, stderr);
      *_errno_location() = 22;
      return 0;
    }
  }
  else
  {
    fwrite("The device string is empty\n", 1u, 0x1Bu, stderr);
    *_errno_location() = 22;
    return 0;
  }
}

//----- (00007958) --------------------------------------------------------
int __cdecl modbus_set_slave_0(modbus_t *ctx, int slave)
{
  if ( (unsigned int)slave < 0xF8 )
  {
    ctx->slave = slave;
    return 0;
  }
  if ( slave == 255 )
  {
    ctx->slave = 255;
    return 0;
  }
  *_errno_location() = 22;
  return -1;
}

//----- (0000799E) --------------------------------------------------------
int __cdecl modbus_tcp_build_request_basis(modbus_t *ctx, int function, int addr, int nb, uint8_t *req)
{
  modbus_tcp_t *ctx_tcp; // [sp+14h] [bp+14h]

  ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
  if ( ctx_tcp->t_id == 0xFFFF )
    ctx_tcp->t_id = 0;
  else
    ++ctx_tcp->t_id;
  *req = HIBYTE(ctx_tcp->t_id);
  req[1] = ctx_tcp->t_id;
  req[2] = 0;
  req[3] = 0;
  req[6] = ctx->slave;
  req[7] = function;
  req[8] = BYTE1(addr);
  req[9] = addr;
  req[10] = BYTE1(nb);
  req[11] = nb;
  return 12;
}

//----- (00007A4C) --------------------------------------------------------
int __cdecl modbus_tcp_build_response_basis(sft_t *sft, uint8_t *rsp)
{
  *rsp = BYTE1(sft->t_id);
  rsp[1] = sft->t_id;
  rsp[2] = 0;
  rsp[3] = 0;
  rsp[6] = sft->slave;
  rsp[7] = sft->function;
  return 8;
}

//----- (00007AA4) --------------------------------------------------------
int __cdecl modbus_tcp_prepare_response_tid(const uint8_t *req, int *req_length)
{
  return (*req << 8) + req[1];
}

//----- (00007AC8) --------------------------------------------------------
int __cdecl modbus_tcp_send_msg_pre(uint8_t *req, int req_length)
{
  req[4] = (unsigned __int16)(req_length - 6) >> 8;
  req[5] = req_length - 6;
  return req_length;
}

//----- (00007AFC) --------------------------------------------------------
ssize_t __cdecl modbus_tcp_send(modbus_t *ctx, const uint8_t *req, int req_length)
{
  return send(ctx->s, req, req_length, 0x4000);
}

//----- (00007B22) --------------------------------------------------------
int __cdecl modbus_tcp_receive(modbus_t *ctx, uint8_t *req)
{
  return j__modbus_receive_msg(ctx, req, MSG_INDICATION);
}

//----- (00007B40) --------------------------------------------------------
ssize_t __cdecl modbus_tcp_recv(modbus_t *ctx, uint8_t *rsp, int rsp_length)
{
  return recv(ctx->s, rsp, rsp_length, 0);
}

//----- (00007B64) --------------------------------------------------------
int __cdecl modbus_tcp_check_integrity(modbus_t *ctx, uint8_t *msg, const int msg_length)
{
  return msg_length;
}

//----- (00007B7E) --------------------------------------------------------
int __cdecl modbus_tcp_pre_check_confirmation(modbus_t *ctx, const uint8_t *req, const uint8_t *rsp, int rsp_length)
{
  if ( *req == *rsp && req[1] == rsp[1] )
  {
    if ( !rsp[2] || !rsp[3] )
      return 0;
    if ( ctx->debug )
      fprintf(stderr, "Invalid protocol ID received 0x%X (not 0x0)\n", (rsp[2] << 8) + rsp[3]);
  }
  else if ( ctx->debug )
  {
    fprintf(stderr, "Invalid transaction ID received 0x%X (not 0x%X)\n", (*rsp << 8) + rsp[1], (*req << 8) + req[1]);
  }
  *_errno_location() = 112345691;
  return -1;
}

//----- (00007C64) --------------------------------------------------------
int __cdecl modbus_tcp_set_ipv4_options(int s)
{
  int option; // [sp+10h] [bp+8h] BYREF
  int rc; // [sp+14h] [bp+Ch]

  option = 1;
  rc = setsockopt(s, 6, 1, &option, 4u);
  if ( rc == -1 )
    return -1;
  option = 16;
  rc = setsockopt(s, 0, 1, &option, 4u);
  if ( rc == -1 )
    return -1;
  else
    return 0;
}

//----- (00007CC6) --------------------------------------------------------
int __cdecl connect(int sockfd, const sockaddr *addr, socklen_t addrlen, const timeval *ro_tv)
{
  __suseconds_t tv_usec; // r1
  int v5; // r3
  fd_set wset; // [sp+1Ch] [bp+14h] BYREF
  timeval tv; // [sp+9Ch] [bp+94h] BYREF
  socklen_t optlen; // [sp+A4h] [bp+9Ch] BYREF
  int optval; // [sp+A8h] [bp+A0h] BYREF
  fd_set *__arr; // [sp+ACh] [bp+A4h]
  int rc; // [sp+B0h] [bp+A8h]
  unsigned int __i; // [sp+B4h] [bp+ACh]
  _DWORD vars0[2]; // [sp+B8h] [bp+B0h] BYREF

  rc = connect(sockfd, addr, addrlen);
  if ( rc != -1 || *_errno_location() != 115 )
    return rc;
  optlen = 4;
  tv_usec = ro_tv->tv_usec;
  tv.tv_sec = ro_tv->tv_sec;
  tv.tv_usec = tv_usec;
  __arr = &wset;
  for ( __i = 0; __i <= 0x1F; ++__i )
    __arr->__fds_bits[__i] = 0;
  LOBYTE(v5) = sockfd & 0x1F;
  if ( sockfd <= 0 )
    v5 = -(-sockfd & 0x1F);
  vars0[sockfd / 32 - 39] |= 1 << v5;
  rc = select(sockfd + 1, 0, &wset, 0, &tv);
  if ( rc <= 0 )
    return -1;
  rc = getsockopt(sockfd, 1, 4, &optval, &optlen);
  if ( !rc && !optval )
    return 0;
  *_errno_location() = 111;
  return -1;
}

//----- (00007DF0) --------------------------------------------------------
int __cdecl modbus_tcp_connect(modbus_t *ctx)
{
  sockaddr_in addr; // [sp+Ch] [bp+Ch] BYREF
  int rc; // [sp+1Ch] [bp+1Ch]
  int flags; // [sp+20h] [bp+20h]
  modbus_tcp_t *ctx_tcp; // [sp+24h] [bp+24h]

  ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
  flags = 526337;
  ctx->s = socket(2, 526337, 0);
  if ( ctx->s == -1 )
    return -1;
  rc = modbus_tcp_set_ipv4_options(ctx->s);
  if ( rc == -1 )
  {
    close(ctx->s);
    ctx->s = -1;
    return -1;
  }
  else
  {
    if ( ctx->debug )
      printf("Connecting to %s:%d\n", ctx_tcp->ip, ctx_tcp->port);
    addr.sin_family = 2;
    addr.sin_port = htons(ctx_tcp->port);
    addr.sin_addr.s_addr = inet_addr(ctx_tcp->ip);
    rc = connect(ctx->s, (const sockaddr *)&addr, 0x10u, &ctx->response_timeout);
    if ( rc == -1 )
    {
      close(ctx->s);
      ctx->s = -1;
      return -1;
    }
    else
    {
      return 0;
    }
  }
}

//----- (00007EE0) --------------------------------------------------------
int __cdecl modbus_tcp_pi_connect(modbus_t *ctx)
{
  struct _IO_FILE *v1; // r4
  const char *v2; // r0
  addrinfo ai_hints; // [sp+8h] [bp+8h] BYREF
  addrinfo *ai_list; // [sp+28h] [bp+28h] BYREF
  int s; // [sp+2Ch] [bp+2Ch]
  int flags; // [sp+30h] [bp+30h]
  int rc; // [sp+34h] [bp+34h]
  modbus_tcp_pi_t *ctx_tcp_pi; // [sp+38h] [bp+38h]
  addrinfo *ai_ptr; // [sp+3Ch] [bp+3Ch]

  ctx_tcp_pi = (modbus_tcp_pi_t *)ctx->backend_data;
  memset(&ai_hints, 0, sizeof(ai_hints));
  ai_hints.ai_flags |= 0x20u;
  ai_hints.ai_family = 0;
  ai_hints.ai_socktype = 1;
  memset(&ai_hints.ai_addr, 0, 12);
  ai_list = 0;
  rc = getaddrinfo(ctx_tcp_pi->node, ctx_tcp_pi->service, &ai_hints, &ai_list);
  if ( rc )
  {
    if ( ctx->debug )
    {
      v1 = stderr;
      v2 = gai_strerror(rc);
      fprintf(v1, "Error returned by getaddrinfo: %s\n", v2);
    }
    *_errno_location() = 111;
    return -1;
  }
  else
  {
    for ( ai_ptr = ai_list; ai_ptr; ai_ptr = ai_ptr->ai_next )
    {
      flags = ai_ptr->ai_socktype;
      flags |= 0x80000u;
      flags |= 0x800u;
      s = socket(ai_ptr->ai_family, flags, ai_ptr->ai_protocol);
      if ( s >= 0 )
      {
        if ( ai_ptr->ai_family == 2 )
          modbus_tcp_set_ipv4_options(s);
        if ( ctx->debug )
          printf("Connecting to [%s]:%s\n", ctx_tcp_pi->node, ctx_tcp_pi->service);
        rc = connect(s, ai_ptr->ai_addr, ai_ptr->ai_addrlen, &ctx->response_timeout);
        if ( rc != -1 )
        {
          ctx->s = s;
          break;
        }
        close(s);
      }
    }
    freeaddrinfo(ai_list);
    if ( ctx->s >= 0 )
      return 0;
    else
      return -1;
  }
}

//----- (00008040) --------------------------------------------------------
void __cdecl modbus_tcp_close(modbus_t *ctx)
{
  if ( ctx->s != -1 )
  {
    shutdown(ctx->s, 2);
    close(ctx->s);
    ctx->s = -1;
  }
}

//----- (00008078) --------------------------------------------------------
int __cdecl modbus_tcp_flush(modbus_t *ctx)
{
  char devnull[260]; // [sp+Ch] [bp+Ch] BYREF
  int rc; // [sp+110h] [bp+110h]
  int rc_sum; // [sp+114h] [bp+114h]

  rc_sum = 0;
  do
  {
    rc = recv(ctx->s, devnull, 0x104u, 64);
    if ( rc > 0 )
      rc_sum += rc;
  }
  while ( rc == 260 );
  return rc_sum;
}

//----- (000080CE) --------------------------------------------------------
int __cdecl modbus_tcp_listen(modbus_t *ctx, int nb_connection)
{
  sockaddr_in addr; // [sp+10h] [bp+8h] BYREF
  int enable; // [sp+20h] [bp+18h] BYREF
  int new_s; // [sp+24h] [bp+1Ch]
  int flags; // [sp+28h] [bp+20h]
  modbus_tcp_t *ctx_tcp; // [sp+2Ch] [bp+24h]

  if ( ctx )
  {
    ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
    flags = 524289;
    new_s = socket(2, 524289, 6);
    if ( new_s == -1 )
    {
      return -1;
    }
    else
    {
      enable = 1;
      if ( setsockopt(new_s, 1, 2, &enable, 4u) == -1 )
      {
        close(new_s);
        return -1;
      }
      else
      {
        memset(&addr, 0, sizeof(addr));
        addr.sin_family = 2;
        addr.sin_port = htons(ctx_tcp->port);
        if ( ctx_tcp->ip[0] == 48 )
          addr.sin_addr.s_addr = htonl(0);
        else
          addr.sin_addr.s_addr = inet_addr(ctx_tcp->ip);
        if ( bind(new_s, (const struct sockaddr *)&addr, 0x10u) == -1 || listen(new_s, nb_connection) == -1 )
        {
          close(new_s);
          return -1;
        }
        else
        {
          return new_s;
        }
      }
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (000081D2) --------------------------------------------------------
int __cdecl modbus_tcp_pi_listen(modbus_t *ctx, int nb_connection)
{
  struct _IO_FILE *v3; // r4
  const char *v4; // r0
  int enable; // [sp+10h] [bp+8h] BYREF
  addrinfo ai_hints; // [sp+14h] [bp+Ch] BYREF
  addrinfo *ai_list; // [sp+34h] [bp+2Ch] BYREF
  int s; // [sp+38h] [bp+30h]
  int flags; // [sp+3Ch] [bp+34h]
  int rc; // [sp+40h] [bp+38h]
  modbus_tcp_pi_t *ctx_tcp_pi; // [sp+44h] [bp+3Ch]
  int new_s; // [sp+48h] [bp+40h]
  const char *service; // [sp+4Ch] [bp+44h]
  const char *node; // [sp+50h] [bp+48h]
  addrinfo *ai_ptr; // [sp+54h] [bp+4Ch]

  if ( ctx )
  {
    ctx_tcp_pi = (modbus_tcp_pi_t *)ctx->backend_data;
    if ( ctx_tcp_pi->node[0] )
      node = ctx_tcp_pi->node;
    else
      node = 0;
    if ( ctx_tcp_pi->service[0] )
      service = ctx_tcp_pi->service;
    else
      service = "502";
    memset(&ai_hints, 0, sizeof(ai_hints));
    ai_hints.ai_flags |= 1u;
    ai_hints.ai_flags |= 0x20u;
    ai_hints.ai_family = 0;
    ai_hints.ai_socktype = 1;
    memset(&ai_hints.ai_addr, 0, 12);
    ai_list = 0;
    rc = getaddrinfo(node, service, &ai_hints, &ai_list);
    if ( rc )
    {
      if ( ctx->debug )
      {
        v3 = stderr;
        v4 = gai_strerror(rc);
        fprintf(v3, "Error returned by getaddrinfo: %s\n", v4);
      }
      *_errno_location() = 111;
      return -1;
    }
    else
    {
      new_s = -1;
      for ( ai_ptr = ai_list; ai_ptr; ai_ptr = ai_ptr->ai_next )
      {
        flags = ai_ptr->ai_socktype;
        flags |= 0x80000u;
        s = socket(ai_ptr->ai_family, flags, ai_ptr->ai_protocol);
        if ( s >= 0 )
        {
          enable = 1;
          rc = setsockopt(s, 1, 2, &enable, 4u);
          if ( rc )
          {
            close(s);
            if ( ctx->debug )
              perror("setsockopt");
          }
          else
          {
            rc = bind(s, ai_ptr->ai_addr, ai_ptr->ai_addrlen);
            if ( rc )
            {
              close(s);
              if ( ctx->debug )
                perror("bind");
            }
            else
            {
              rc = listen(s, nb_connection);
              if ( !rc )
              {
                new_s = s;
                break;
              }
              close(s);
              if ( ctx->debug )
                perror("listen");
            }
          }
        }
        else if ( ctx->debug )
        {
          perror("socket");
        }
      }
      freeaddrinfo(ai_list);
      if ( new_s >= 0 )
        return new_s;
      else
        return -1;
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (000083E8) --------------------------------------------------------
int __cdecl modbus_tcp_accept(modbus_t *ctx, int *s)
{
  char *v3; // r0
  socklen_t addrlen; // [sp+Ch] [bp+Ch] BYREF
  sockaddr_in addr; // [sp+10h] [bp+10h] BYREF

  if ( ctx )
  {
    addrlen = 16;
    ctx->s = accept4(*s, &addr, &addrlen, 0x80000);
    if ( ctx->s == -1 )
    {
      return -1;
    }
    else
    {
      if ( ctx->debug )
      {
        v3 = inet_ntoa(addr.sin_addr);
        printf("The client connection from %s is accepted\n", v3);
      }
      return ctx->s;
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}
// 27E0: using guessed type int __fastcall accept4(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00008464) --------------------------------------------------------
int __cdecl modbus_tcp_pi_accept(modbus_t *ctx, int *s)
{
  socklen_t addrlen; // [sp+Ch] [bp+Ch] BYREF
  sockaddr_storage addr; // [sp+10h] [bp+10h] BYREF

  if ( ctx )
  {
    addrlen = 128;
    ctx->s = accept4(*s, &addr, &addrlen, 0x80000);
    if ( ctx->s == -1 )
    {
      return -1;
    }
    else
    {
      if ( ctx->debug )
        puts("The client connection is accepted.");
      return ctx->s;
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}
// 27E0: using guessed type int __fastcall accept4(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000084D4) --------------------------------------------------------
int __cdecl modbus_tcp_select(modbus_t *ctx, fd_set *rset, timeval *tv, int length_to_read)
{
  int i; // r0
  bool v5; // nf
  int v6; // r0
  int s; // r3
  int v8; // r0
  unsigned int __i; // [sp+24h] [bp+1Ch]

  for ( i = select(ctx->s + 1, rset, 0, 0, tv); i == -1; i = select(ctx->s + 1, rset, 0, 0, tv) )
  {
    if ( *_errno_location() != 4 )
      return -1;
    if ( ctx->debug )
      fwrite("A non blocked signal was caught\n", 1u, 0x20u, stderr);
    for ( __i = 0; __i <= 0x1F; ++__i )
      rset->__fds_bits[__i] = 0;
    s = ctx->s;
    v6 = -s;
    v5 = -s < 0;
    LOBYTE(s) = s & 0x1F;
    v8 = v6 & 0x1F;
    if ( !v5 )
      s = -v8;
    rset->__fds_bits[ctx->s / 32] |= 1 << s;
  }
  if ( i )
    return i;
  *_errno_location() = 110;
  return -1;
}

//----- (000085BC) --------------------------------------------------------
void __cdecl modbus_tcp_free(modbus_t *ctx)
{
  free(ctx->backend_data);
  free(ctx);
}

//----- (000085DC) --------------------------------------------------------
modbus_t *__cdecl modbus_new_tcp(const char *ip, int port)
{
  size_t ret_size; // [sp+8h] [bp+8h]
  modbus_tcp_t *ctx_tcp; // [sp+10h] [bp+10h]
  modbus_t *ctx; // [sp+14h] [bp+14h]

  ctx = (modbus_t *)malloc(0x30u);
  if ( !ctx )
    return 0;
  j__modbus_init_common(ctx);
  ctx->slave = 255;
  ctx->backend = &modbus_tcp_backend;
  ctx->backend_data = malloc(0x18u);
  if ( ctx->backend_data )
  {
    ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
    if ( ip )
    {
      ret_size = j_strlcpy(ctx_tcp->ip, ip, 0x10u);
      if ( !ret_size )
      {
        fwrite("The IP string is empty\n", 1u, 0x17u, stderr);
        j_modbus_free(ctx);
        *_errno_location() = 22;
        return 0;
      }
      if ( ret_size >= 0x10 )
      {
        fwrite("The IP string has been truncated\n", 1u, 0x21u, stderr);
        j_modbus_free(ctx);
        *_errno_location() = 22;
        return 0;
      }
    }
    else
    {
      ctx_tcp->ip[0] = 48;
    }
    ctx_tcp->port = port;
    ctx_tcp->t_id = 0;
    return ctx;
  }
  j_modbus_free(ctx);
  *_errno_location() = 12;
  return 0;
}

//----- (000086E8) --------------------------------------------------------
modbus_t *__cdecl modbus_new_tcp_pi(const char *node, const char *service)
{
  modbus_tcp_pi_t *ctx_tcp_pi; // [sp+8h] [bp+8h]
  modbus_t *ctx; // [sp+Ch] [bp+Ch]
  size_t ret_size; // [sp+10h] [bp+10h]
  size_t ret_sizea; // [sp+10h] [bp+10h]
  size_t dest_size; // [sp+14h] [bp+14h]

  ctx = (modbus_t *)malloc(0x30u);
  if ( !ctx )
    return 0;
  j__modbus_init_common(ctx);
  ctx->slave = 255;
  ctx->backend = &modbus_tcp_pi_backend;
  ctx->backend_data = malloc(0x42Cu);
  if ( ctx->backend_data )
  {
    ctx_tcp_pi = (modbus_tcp_pi_t *)ctx->backend_data;
    if ( node )
    {
      dest_size = 1025;
      ret_size = j_strlcpy(ctx_tcp_pi->node, node, 0x401u);
      if ( !ret_size )
      {
        fwrite("The node string is empty\n", 1u, 0x19u, stderr);
        j_modbus_free(ctx);
        *_errno_location() = 22;
        return 0;
      }
      if ( ret_size >= 0x401 )
      {
        fwrite("The node string has been truncated\n", 1u, 0x23u, stderr);
        j_modbus_free(ctx);
        *_errno_location() = 22;
        return 0;
      }
    }
    else
    {
      ctx_tcp_pi->node[0] = 0;
    }
    if ( service )
    {
      dest_size = 32;
      ret_sizea = j_strlcpy(ctx_tcp_pi->service, service, 0x20u);
    }
    else
    {
      ret_sizea = 0;
    }
    if ( ret_sizea )
    {
      if ( ret_sizea < dest_size )
      {
        ctx_tcp_pi->t_id = 0;
        return ctx;
      }
      else
      {
        fwrite("The service string has been truncated\n", 1u, 0x26u, stderr);
        j_modbus_free(ctx);
        *_errno_location() = 22;
        return 0;
      }
    }
    else
    {
      fwrite("The service string is empty\n", 1u, 0x1Cu, stderr);
      j_modbus_free(ctx);
      *_errno_location() = 22;
      return 0;
    }
  }
  else
  {
    j_modbus_free(ctx);
    *_errno_location() = 12;
    return 0;
  }
}
// 8822: variable 'dest_size' is possibly undefined

//----- (00008878) --------------------------------------------------------
const char *__cdecl modbus_strerror(int errnum)
{
  char *v1; // r3

  switch ( errnum )
  {
    case 112345679:
      v1 = "Illegal function";
      break;
    case 112345680:
      v1 = "Illegal data address";
      break;
    case 112345681:
      v1 = "Illegal data value";
      break;
    case 112345682:
      v1 = "Slave device or server failure";
      break;
    case 112345683:
      v1 = "Acknowledge";
      break;
    case 112345684:
      v1 = "Slave device or server is busy";
      break;
    case 112345685:
      v1 = "Negative acknowledge";
      break;
    case 112345686:
      v1 = "Memory parity error";
      break;
    case 112345688:
      v1 = "Gateway path unavailable";
      break;
    case 112345689:
      v1 = "Target device failed to respond";
      break;
    case 112345690:
      v1 = "Invalid CRC";
      break;
    case 112345691:
      v1 = "Invalid data";
      break;
    case 112345692:
      v1 = "Invalid exception code";
      break;
    case 112345694:
      v1 = "Too many data";
      break;
    case 112345695:
      v1 = "Response not from requested slave";
      break;
    default:
      v1 = strerror(errnum);
      break;
  }
  return v1;
}

//----- (00008988) --------------------------------------------------------
void __cdecl error_print(modbus_t *ctx, const char *context)
{
  struct _IO_FILE *v2; // r5
  int *v3; // r0
  const char *v4; // r0

  if ( ctx->debug )
  {
    v2 = stderr;
    v3 = _errno_location();
    v4 = j_modbus_strerror(*v3);
    fprintf(v2, "ERROR %s", v4);
    if ( context )
      fprintf(stderr, ": %s\n", context);
    else
      fputc(10, stderr);
  }
}

//----- (00008A04) --------------------------------------------------------
void __cdecl sleep_response_timeout(modbus_t *ctx)
{
  timespec remaining; // [sp+8h] [bp+8h] BYREF
  timespec request; // [sp+10h] [bp+10h] BYREF

  request.tv_sec = ctx->response_timeout.tv_sec;
  request.tv_nsec = 1000 * ctx->response_timeout.tv_usec;
  while ( nanosleep(&request, &remaining) == -1 && *_errno_location() == 4 )
    request = remaining;
}

//----- (00008A5E) --------------------------------------------------------
int __cdecl modbus_flush(modbus_t *ctx)
{
  int rc; // [sp+Ch] [bp+Ch]

  if ( ctx )
  {
    rc = ctx->backend->flush(ctx);
    if ( rc != -1 && ctx->debug )
      printf("Bytes flushed (%d)\n", rc);
    return rc;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (00008AB4) --------------------------------------------------------
unsigned int __cdecl compute_response_length_from_request(modbus_t *ctx, uint8_t *req)
{
  int offset; // [sp+10h] [bp+10h]
  int length; // [sp+14h] [bp+14h]

  offset = ctx->backend->header_length;
  switch ( req[offset] )
  {
    case 1u:
    case 2u:
      length = ((req[offset + 3] << 8) | req[offset + 4]) / 8 + 2 + ((req[offset + 4] & 7) != 0);
      return ctx->backend->checksum_length + length + offset;
    case 3u:
    case 4u:
    case 0x17u:
      length = 2 * (((req[offset + 3] << 8) | req[offset + 4]) + 1);
      return ctx->backend->checksum_length + length + offset;
    case 7u:
      length = 3;
      return ctx->backend->checksum_length + length + offset;
    case 0x11u:
      return -1;
    case 0x16u:
      length = 7;
      return ctx->backend->checksum_length + length + offset;
    default:
      length = 5;
      return ctx->backend->checksum_length + length + offset;
  }
}

//----- (00008BCE) --------------------------------------------------------
int __cdecl send_msg(modbus_t *ctx, uint8_t *msg, int msg_length)
{
  int msg_lengtha; // [sp+4h] [bp+4h]
  int saved_errno; // [sp+14h] [bp+14h]
  int rc; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  msg_lengtha = ctx->backend->send_msg_pre(msg, msg_length);
  if ( ctx->debug )
  {
    for ( i = 0; i < msg_lengtha; ++i )
      printf("[%.2X]", msg[i]);
    putchar(10);
  }
  do
  {
    rc = ctx->backend->send(ctx, msg, msg_lengtha);
    if ( rc == -1 )
    {
      j__error_print(ctx, 0);
      if ( (ctx->error_recovery & 2) != 0 )
      {
        saved_errno = *_errno_location();
        if ( *_errno_location() == 9 || *_errno_location() == 104 || *_errno_location() == 32 )
        {
          j_modbus_close(ctx);
          sleep_response_timeout(ctx);
          j_modbus_connect(ctx);
        }
        else
        {
          sleep_response_timeout(ctx);
          j_modbus_flush(ctx);
        }
        *_errno_location() = saved_errno;
      }
    }
  }
  while ( (ctx->error_recovery & 2) != 0 && rc == -1 );
  if ( rc <= 0 || rc == msg_lengtha )
    return rc;
  *_errno_location() = 112345691;
  return -1;
}

//----- (00008CE8) --------------------------------------------------------
int __cdecl modbus_send_raw_request(modbus_t *ctx, const uint8_t *raw_req, int raw_req_length)
{
  uint8_t req[260]; // [sp+14h] [bp+14h] BYREF
  sft_t sft; // [sp+118h] [bp+118h] BYREF
  int req_length; // [sp+124h] [bp+124h]

  if ( ctx && raw_req_length > 1 && raw_req_length <= 254 )
  {
    sft.slave = *raw_req;
    sft.function = raw_req[1];
    sft.t_id = 0;
    req_length = ctx->backend->build_response_basis(&sft, req);
    if ( raw_req_length > 2 )
    {
      memcpy(&req[req_length], raw_req + 2, raw_req_length - 2);
      req_length += raw_req_length - 2;
    }
    return send_msg(ctx, req, req_length);
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (00008DC6) --------------------------------------------------------
uint8_t __cdecl compute_meta_length_after_function(int function, msg_type_t msg_type)
{
  uint8_t length; // [sp+Ch] [bp+Ch]

  if ( msg_type )
  {
    switch ( function )
    {
      case 5:
      case 6:
      case 15:
      case 16:
        length = 4;
        break;
      case 22:
        length = 6;
        break;
      default:
        length = 1;
        break;
    }
  }
  else if ( function > 6 )
  {
    switch ( function )
    {
      case 15:
      case 16:
        return 5;
      case 22:
        return 6;
      case 23:
        return 9;
      default:
        return 0;
    }
  }
  else
  {
    return 4;
  }
  return length;
}

//----- (00008E8C) --------------------------------------------------------
int __cdecl compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)
{
  int function; // [sp+10h] [bp+10h]
  int length; // [sp+14h] [bp+14h]

  function = msg[ctx->backend->header_length];
  if ( msg_type )
  {
    if ( msg[ctx->backend->header_length] <= 4u || function == 17 || function == 23 )
      length = msg[ctx->backend->header_length + 1];
    else
      length = 0;
  }
  else
  {
    if ( msg[ctx->backend->header_length] < 0xFu )
    {
LABEL_8:
      length = 0;
      return length + ctx->backend->checksum_length;
    }
    if ( msg[ctx->backend->header_length] <= 0x10u )
    {
      length = msg[ctx->backend->header_length + 5];
    }
    else
    {
      if ( function != 23 )
        goto LABEL_8;
      length = msg[ctx->backend->header_length + 9];
    }
  }
  return length + ctx->backend->checksum_length;
}

//----- (00008F28) --------------------------------------------------------
int __cdecl modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)
{
  bool v3; // nf
  int v4; // r0
  int s; // r3
  int v6; // r0
  timeval tv; // [sp+10h] [bp+10h] BYREF
  fd_set rset; // [sp+18h] [bp+18h] BYREF
  int saved_errno; // [sp+98h] [bp+98h]
  int saved_errno_0; // [sp+9Ch] [bp+9Ch]
  fd_set *__arr; // [sp+A0h] [bp+A0h]
  int i; // [sp+A4h] [bp+A4h]
  unsigned int __i; // [sp+A8h] [bp+A8h]
  _step_t step; // [sp+ACh] [bp+ACh]
  int msg_length; // [sp+B0h] [bp+B0h]
  int length_to_read; // [sp+B4h] [bp+B4h]
  timeval *p_tv; // [sp+B8h] [bp+B8h]
  int rc; // [sp+BCh] [bp+BCh]
  _BYTE v24[4]; // [sp+C0h] [bp+C0h] BYREF

  msg_length = 0;
  if ( ctx->debug )
  {
    if ( msg_type )
      puts("Waiting for a confirmation...");
    else
      puts("Waiting for an indication...");
  }
  __arr = &rset;
  for ( __i = 0; __i <= 0x1F; ++__i )
    __arr->__fds_bits[__i] = 0;
  s = ctx->s;
  v4 = -s;
  v3 = -s < 0;
  LOBYTE(s) = s & 0x1F;
  v6 = v4 & 0x1F;
  if ( !v3 )
    s = -v6;
  *(_DWORD *)&v24[4 * (ctx->s / 32) - 168] |= 1 << s;
  step = _STEP_FUNCTION;
  length_to_read = ctx->backend->header_length + 1;
  if ( msg_type )
  {
    tv = ctx->response_timeout;
    p_tv = &tv;
  }
  else if ( ctx->indication_timeout.tv_sec || ctx->indication_timeout.tv_usec )
  {
    tv = ctx->indication_timeout;
    p_tv = &tv;
  }
  else
  {
    p_tv = 0;
  }
  while ( 1 )
  {
    if ( !length_to_read )
    {
      if ( ctx->debug )
        putchar(10);
      return ctx->backend->check_integrity(ctx, msg, msg_length);
    }
    rc = ctx->backend->select(ctx, &rset, p_tv, length_to_read);
    if ( rc == -1 )
    {
      j__error_print(ctx, "select");
      if ( (ctx->error_recovery & 2) != 0 )
      {
        saved_errno = *_errno_location();
        if ( *_errno_location() == 110 )
        {
          sleep_response_timeout(ctx);
          j_modbus_flush(ctx);
        }
        else if ( *_errno_location() == 9 )
        {
          j_modbus_close(ctx);
          j_modbus_connect(ctx);
        }
        *_errno_location() = saved_errno;
      }
      return -1;
    }
    rc = ctx->backend->recv(ctx, &msg[msg_length], length_to_read);
    if ( !rc )
    {
      *_errno_location() = 104;
      rc = -1;
    }
    if ( rc == -1 )
      break;
    if ( ctx->debug )
    {
      for ( i = 0; i < rc; ++i )
        printf("<%.2X>", msg[i + msg_length]);
    }
    msg_length += rc;
    length_to_read -= rc;
    if ( !length_to_read )
    {
      if ( step )
      {
        if ( step != _STEP_META )
          goto LABEL_46;
      }
      else
      {
        length_to_read = compute_meta_length_after_function(msg[ctx->backend->header_length], msg_type);
        if ( length_to_read )
        {
          step = _STEP_META;
          goto LABEL_46;
        }
      }
      length_to_read = compute_data_length_after_meta(ctx, msg, msg_type);
      if ( length_to_read + msg_length > (signed int)ctx->backend->max_adu_length )
      {
        *_errno_location() = 112345691;
        j__error_print(ctx, "too many data");
        return -1;
      }
      step = _STEP_DATA;
    }
LABEL_46:
    if ( length_to_read > 0 && (ctx->byte_timeout.tv_sec > 0 || ctx->byte_timeout.tv_usec > 0) )
    {
      tv = ctx->byte_timeout;
      p_tv = &tv;
    }
  }
  j__error_print(ctx, "read");
  if ( (ctx->error_recovery & 2) != 0
    && (*_errno_location() == 104 || *_errno_location() == 111 || *_errno_location() == 9) )
  {
    saved_errno_0 = *_errno_location();
    j_modbus_close(ctx);
    j_modbus_connect(ctx);
    *_errno_location() = saved_errno_0;
  }
  return -1;
}

//----- (000092C4) --------------------------------------------------------
int __cdecl modbus_receive(modbus_t *ctx, uint8_t *req)
{
  if ( ctx )
    return ctx->backend->receive(ctx, req);
  *_errno_location() = 22;
  return -1;
}

//----- (000092FA) --------------------------------------------------------
int __cdecl modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp)
{
  if ( ctx )
    return j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
  *_errno_location() = 22;
  return -1;
}

//----- (0000932E) --------------------------------------------------------
int __cdecl check_confirmation(modbus_t *ctx, uint8_t *req, uint8_t *rsp, int rsp_length)
{
  int exception_code; // [sp+14h] [bp+14h]
  unsigned int rsp_length_computed; // [sp+18h] [bp+18h]
  int function; // [sp+1Ch] [bp+1Ch]
  int offset; // [sp+20h] [bp+20h]
  int rsp_nb_value; // [sp+24h] [bp+24h]
  int req_nb_value; // [sp+28h] [bp+28h]

  offset = ctx->backend->header_length;
  function = rsp[offset];
  if ( ctx->backend->pre_check_confirmation && ctx->backend->pre_check_confirmation(ctx, req, rsp, rsp_length) == -1 )
  {
    if ( (ctx->error_recovery & 4) != 0 )
    {
      sleep_response_timeout(ctx);
      j_modbus_flush(ctx);
    }
    return -1;
  }
  rsp_length_computed = compute_response_length_from_request(ctx, req);
  if ( function > 127 )
  {
    if ( offset + ctx->backend->checksum_length + 2 == rsp_length && req[offset] == rsp[offset] - 128 )
    {
      if ( rsp[offset + 1] > 0xBu )
      {
        *_errno_location() = 112345692;
      }
      else
      {
        exception_code = rsp[offset + 1];
        *_errno_location() = exception_code + 112345678;
      }
      j__error_print(ctx, 0);
      return -1;
    }
    else
    {
      *_errno_location() = 112345692;
      j__error_print(ctx, 0);
      return -1;
    }
  }
  if ( rsp_length != rsp_length_computed && rsp_length_computed != -1 )
  {
    if ( ctx->debug )
      fprintf(
        stderr,
        "Message length not corresponding to the computed length (%d != %d)\n",
        rsp_length,
        rsp_length_computed);
    if ( (ctx->error_recovery & 4) != 0 )
    {
      sleep_response_timeout(ctx);
      j_modbus_flush(ctx);
    }
    goto LABEL_39;
  }
  if ( req[offset] == function )
  {
    switch ( function )
    {
      case 1:
      case 2:
        req_nb_value = ((req[offset + 4] & 7) != 0) + ((req[offset + 3] << 8) + req[offset + 4]) / 8;
        rsp_nb_value = rsp[offset + 1];
        break;
      case 3:
      case 4:
      case 23:
        req_nb_value = (req[offset + 3] << 8) + req[offset + 4];
        rsp_nb_value = rsp[offset + 1] >> 1;
        break;
      case 15:
      case 16:
        req_nb_value = (req[offset + 3] << 8) + req[offset + 4];
        rsp_nb_value = (rsp[offset + 3] << 8) | rsp[offset + 4];
        break;
      case 17:
        rsp_nb_value = rsp[offset + 1];
        req_nb_value = rsp_nb_value;
        break;
      default:
        rsp_nb_value = 1;
        req_nb_value = 1;
        break;
    }
    if ( req_nb_value == rsp_nb_value )
      return rsp_nb_value;
    if ( ctx->debug )
      fprintf(stderr, "Quantity not corresponding to the request (%d != %d)\n", rsp_nb_value, req_nb_value);
    if ( (ctx->error_recovery & 4) != 0 )
    {
      sleep_response_timeout(ctx);
      j_modbus_flush(ctx);
    }
LABEL_39:
    *_errno_location() = 112345691;
    return -1;
  }
  if ( ctx->debug )
    fprintf(stderr, "Received function not corresponding to the request (0x%X != 0x%X)\n", function, req[offset]);
  if ( (ctx->error_recovery & 4) != 0 )
  {
    sleep_response_timeout(ctx);
    j_modbus_flush(ctx);
  }
  *_errno_location() = 112345691;
  return -1;
}
// 944C: conditional instruction was optimized away because %function.4<80u

//----- (000096A8) --------------------------------------------------------
int __cdecl response_io_status(uint8_t *tab_io_status, int address, int nb, uint8_t *rsp, int offset)
{
  int v5; // r3
  int v6; // r3
  int i; // [sp+14h] [bp+14h]
  int one_byte; // [sp+18h] [bp+18h]
  int shift; // [sp+1Ch] [bp+1Ch]

  shift = 0;
  one_byte = 0;
  for ( i = address; address + nb > i; ++i )
  {
    one_byte |= tab_io_status[i] << shift;
    if ( shift == 7 )
    {
      v5 = offset++;
      rsp[v5] = one_byte;
      shift = 0;
      one_byte = 0;
    }
    else
    {
      ++shift;
    }
  }
  if ( shift )
  {
    v6 = offset++;
    rsp[v6] = one_byte;
  }
  return offset;
}

//----- (0000973A) --------------------------------------------------------
int response_exception(
        modbus_t *ctx,
        sft_t *sft,
        int exception_code,
        uint8_t *rsp,
        unsigned int to_flush,
        const char *a6,
        ...)
{
  int v6; // r0
  uint8_t exception_codea; // [sp+4h] [bp+4h]
  va_list va; // [sp+28h] [bp+28h] BYREF

  va_start(va, a6);
  exception_codea = exception_code;
  if ( ctx->debug )
    vfprintf(stderr, a6, va);
  if ( to_flush )
  {
    sleep_response_timeout(ctx);
    j_modbus_flush(ctx);
  }
  sft->function += 128;
  v6 = ctx->backend->build_response_basis(sft, rsp);
  rsp[v6] = exception_codea;
  return v6 + 1;
}

//----- (000097BC) --------------------------------------------------------
int __cdecl modbus_reply(modbus_t *ctx, const uint8_t *req, int req_length, modbus_mapping_t *mb_mapping)
{
  int start_input_bits; // r3
  int nb_input_bits; // r3
  uint8_t *tab_input_bits; // r3
  const char *v8; // r3
  int v9; // r3
  int v10; // r0
  int start_input_registers; // r3
  int nb_input_registers; // r3
  uint16_t *tab_input_registers; // r3
  const char *v14; // r3
  int v15; // r3
  int v16; // r0
  int v17; // r3
  int v18; // r3
  int v19; // r3
  int v20; // r3
  int v21; // r3
  int v22; // r3
  int v23; // r2
  int v24; // r0
  int v25; // r3
  int v26; // r3
  int req_lengtha; // [sp+1Ch] [bp+4h] BYREF
  const uint8_t *reqa; // [sp+20h] [bp+8h]
  modbus_t *ctxa; // [sp+24h] [bp+Ch]
  sft_t sft; // [sp+2Ch] [bp+14h] BYREF
  uint8_t rsp[260]; // [sp+38h] [bp+20h] BYREF
  int mapping_address_write; // [sp+13Ch] [bp+124h]
  int mapping_address_6; // [sp+140h] [bp+128h]
  int nb_write_bytes; // [sp+144h] [bp+12Ch]
  int nb_write; // [sp+148h] [bp+130h]
  uint16_t address_write; // [sp+14Eh] [bp+136h]
  int nb_3; // [sp+150h] [bp+138h]
  uint16_t or; // [sp+156h] [bp+13Eh]
  uint16_t and; // [sp+158h] [bp+140h]
  uint16_t data_1; // [sp+15Ah] [bp+142h]
  int mapping_address_5; // [sp+15Ch] [bp+144h]
  int str_len; // [sp+160h] [bp+148h]
  int byte_count_pos; // [sp+164h] [bp+14Ch]
  int mapping_address_4; // [sp+168h] [bp+150h]
  int nb_bytes; // [sp+16Ch] [bp+154h]
  int nb_2; // [sp+170h] [bp+158h]
  int mapping_address_3; // [sp+174h] [bp+15Ch]
  int nb_bits_0; // [sp+178h] [bp+160h]
  int nb_1; // [sp+17Ch] [bp+164h]
  int data_0; // [sp+180h] [bp+168h]
  int mapping_address_2; // [sp+184h] [bp+16Ch]
  int data; // [sp+188h] [bp+170h]
  int mapping_address_1; // [sp+18Ch] [bp+174h]
  int mapping_address_0; // [sp+190h] [bp+178h]
  int nb_0; // [sp+194h] [bp+17Ch]
  const char *name_0; // [sp+198h] [bp+180h]
  uint16_t *tab_registers; // [sp+19Ch] [bp+184h]
  int nb_registers; // [sp+1A0h] [bp+188h]
  int start_registers; // [sp+1A4h] [bp+18Ch]
  unsigned int is_input_0; // [sp+1A8h] [bp+190h]
  int mapping_address; // [sp+1ACh] [bp+194h]
  int nb; // [sp+1B0h] [bp+198h]
  const char *name; // [sp+1B4h] [bp+19Ch]
  uint8_t *tab_bits; // [sp+1B8h] [bp+1A0h]
  int nb_bits; // [sp+1BCh] [bp+1A4h]
  int start_bits; // [sp+1C0h] [bp+1A8h]
  unsigned int is_input; // [sp+1C4h] [bp+1ACh]
  uint16_t address; // [sp+1CAh] [bp+1B2h]
  int function; // [sp+1CCh] [bp+1B4h]
  int slave; // [sp+1D0h] [bp+1B8h]
  int offset; // [sp+1D4h] [bp+1BCh]
  int j_0; // [sp+1D8h] [bp+1C0h]
  int i_1; // [sp+1DCh] [bp+1C4h]
  int j; // [sp+1E0h] [bp+1C8h]
  int i_0; // [sp+1E4h] [bp+1CCh]
  int i; // [sp+1E8h] [bp+1D0h]
  int rsp_length; // [sp+1ECh] [bp+1D4h]

  ctxa = ctx;
  reqa = req;
  req_lengtha = req_length;
  rsp_length = 0;
  if ( ctx )
  {
    offset = ctxa->backend->header_length;
    slave = reqa[offset - 1];
    function = reqa[offset];
    address = reqa[offset + 2] + (reqa[offset + 1] << 8);
    sft.slave = slave;
    sft.function = function;
    sft.t_id = ctxa->backend->prepare_response_tid(reqa, &req_lengtha);
    switch ( function )
    {
      case 1:
      case 2:
        is_input = function == 2;
        if ( function == 2 )
          start_input_bits = mb_mapping->start_input_bits;
        else
          start_input_bits = mb_mapping->start_bits;
        start_bits = start_input_bits;
        if ( is_input )
          nb_input_bits = mb_mapping->nb_input_bits;
        else
          nb_input_bits = mb_mapping->nb_bits;
        nb_bits = nb_input_bits;
        if ( is_input )
          tab_input_bits = mb_mapping->tab_input_bits;
        else
          tab_input_bits = mb_mapping->tab_bits;
        tab_bits = tab_input_bits;
        if ( is_input )
          v8 = "read_input_bits";
        else
          v8 = "read_bits";
        name = v8;
        nb = (reqa[offset + 3] << 8) + reqa[offset + 4];
        mapping_address = address - start_bits;
        if ( nb > 0 && nb <= 2000 )
        {
          if ( mapping_address >= 0 && mapping_address + nb <= nb_bits )
          {
            v10 = ctxa->backend->build_response_basis(&sft, rsp);
            rsp_length = v10 + 1;
            rsp[v10] = nb / 8 + ((nb & 7) != 0);
            rsp_length = response_io_status(tab_bits, mapping_address, nb, rsp, rsp_length);
          }
          else
          {
            if ( mapping_address >= 0 )
              v9 = nb + address;
            else
              v9 = address;
            rsp_length = response_exception(ctxa, &sft, 2, rsp, 0, "Illegal data address 0x%0X in %s\n", v9, name);
          }
        }
        else
        {
          rsp_length = response_exception(
                         ctxa,
                         &sft,
                         3,
                         rsp,
                         1u,
                         "Illegal nb of values %d in %s (max %d)\n",
                         nb,
                         name,
                         2000);
        }
        break;
      case 3:
      case 4:
        is_input_0 = function == 4;
        if ( function == 4 )
          start_input_registers = mb_mapping->start_input_registers;
        else
          start_input_registers = mb_mapping->start_registers;
        start_registers = start_input_registers;
        if ( is_input_0 )
          nb_input_registers = mb_mapping->nb_input_registers;
        else
          nb_input_registers = mb_mapping->nb_registers;
        nb_registers = nb_input_registers;
        if ( is_input_0 )
          tab_input_registers = mb_mapping->tab_input_registers;
        else
          tab_input_registers = mb_mapping->tab_registers;
        tab_registers = tab_input_registers;
        if ( is_input_0 )
          v14 = "read_input_registers";
        else
          v14 = "read_registers";
        name_0 = v14;
        nb_0 = (reqa[offset + 3] << 8) + reqa[offset + 4];
        mapping_address_0 = address - start_registers;
        if ( nb_0 > 0 && nb_0 <= 125 )
        {
          if ( mapping_address_0 >= 0 && mapping_address_0 + nb_0 <= nb_registers )
          {
            v16 = ctxa->backend->build_response_basis(&sft, rsp);
            rsp_length = v16 + 1;
            rsp[v16] = 2 * nb_0;
            for ( i = mapping_address_0; mapping_address_0 + nb_0 > i; ++i )
            {
              v17 = rsp_length++;
              rsp[v17] = HIBYTE(tab_registers[i]);
              v18 = rsp_length++;
              rsp[v18] = tab_registers[i];
            }
          }
          else
          {
            if ( mapping_address_0 >= 0 )
              v15 = nb_0 + address;
            else
              v15 = address;
            rsp_length = response_exception(ctxa, &sft, 2, rsp, 0, "Illegal data address 0x%0X in %s\n", v15, name_0);
          }
        }
        else
        {
          rsp_length = response_exception(
                         ctxa,
                         &sft,
                         3,
                         rsp,
                         1u,
                         "Illegal nb of values %d in %s (max %d)\n",
                         nb_0,
                         name_0,
                         125);
        }
        break;
      case 5:
        mapping_address_1 = address - mb_mapping->start_bits;
        if ( mapping_address_1 >= 0 && mb_mapping->nb_bits > mapping_address_1 )
        {
          data = (reqa[offset + 3] << 8) + reqa[offset + 4];
          if ( data != 65280 && data )
          {
            rsp_length = response_exception(
                           ctxa,
                           &sft,
                           3,
                           rsp,
                           0,
                           "Illegal data value 0x%0X in write_bit request at address %0X\n",
                           data,
                           address);
          }
          else
          {
            mb_mapping->tab_bits[mapping_address_1] = data != 0;
            memcpy(rsp, reqa, req_lengtha);
            rsp_length = req_lengtha;
          }
        }
        else
        {
          rsp_length = response_exception(ctxa, &sft, 2, rsp, 0, "Illegal data address 0x%0X in write_bit\n", address);
        }
        break;
      case 6:
        mapping_address_2 = address - mb_mapping->start_registers;
        if ( mapping_address_2 < 0 || mb_mapping->nb_registers <= mapping_address_2 )
          goto LABEL_60;
        data_0 = (reqa[offset + 3] << 8) + reqa[offset + 4];
        mb_mapping->tab_registers[mapping_address_2] = data_0;
        memcpy(rsp, reqa, req_lengtha);
        rsp_length = req_lengtha;
        break;
      case 7:
        if ( ctxa->debug )
          fwrite("FIXME Not implemented\n", 1u, 0x16u, stderr);
        *_errno_location() = 92;
        return -1;
      case 15:
        nb_1 = (reqa[offset + 3] << 8) + reqa[offset + 4];
        nb_bits_0 = reqa[offset + 5];
        mapping_address_3 = address - mb_mapping->start_bits;
        if ( nb_1 > 0 && nb_1 <= 1968 && 8 * nb_bits_0 >= nb_1 )
        {
          if ( mapping_address_3 >= 0 && mapping_address_3 + nb_1 <= mb_mapping->nb_bits )
          {
            j_modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address_3, nb_1, &reqa[offset + 6]);
            rsp_length = ctxa->backend->build_response_basis(&sft, rsp);
            *(_DWORD *)&rsp[rsp_length] = *(_DWORD *)&reqa[rsp_length];
            rsp_length += 4;
          }
          else
          {
            if ( mapping_address_3 >= 0 )
              v19 = nb_1 + address;
            else
              v19 = address;
            rsp_length = response_exception(ctxa, &sft, 2, rsp, 0, "Illegal data address 0x%0X in write_bits\n", v19);
          }
        }
        else
        {
          rsp_length = response_exception(
                         ctxa,
                         &sft,
                         3,
                         rsp,
                         1u,
                         "Illegal number of values %d in write_bits (max %d)\n",
                         nb_1,
                         1968);
        }
        break;
      case 16:
        nb_2 = (reqa[offset + 3] << 8) + reqa[offset + 4];
        nb_bytes = reqa[offset + 5];
        mapping_address_4 = address - mb_mapping->start_registers;
        if ( nb_2 > 0 && nb_2 <= 123 && 2 * nb_2 == nb_bytes )
        {
          if ( mapping_address_4 >= 0 && mapping_address_4 + nb_2 <= mb_mapping->nb_registers )
          {
            i_0 = mapping_address_4;
            j = 6;
            while ( mapping_address_4 + nb_2 > i_0 )
            {
              mb_mapping->tab_registers[i_0++] = reqa[j + 1 + offset] + (reqa[j + offset] << 8);
              j += 2;
            }
            rsp_length = ctxa->backend->build_response_basis(&sft, rsp);
            *(_DWORD *)&rsp[rsp_length] = *(_DWORD *)&reqa[rsp_length];
            rsp_length += 4;
          }
          else
          {
            if ( mapping_address_4 >= 0 )
              v20 = nb_2 + address;
            else
              v20 = address;
            rsp_length = response_exception(
                           ctxa,
                           &sft,
                           2,
                           rsp,
                           0,
                           "Illegal data address 0x%0X in write_registers\n",
                           v20);
          }
        }
        else
        {
          rsp_length = response_exception(
                         ctxa,
                         &sft,
                         3,
                         rsp,
                         1u,
                         "Illegal number of values %d in write_registers (max %d)\n",
                         nb_2,
                         123);
        }
        break;
      case 17:
        byte_count_pos = ctxa->backend->build_response_basis(&sft, rsp);
        rsp_length = byte_count_pos + 2;
        rsp[byte_count_pos + 1] = -76;
        v21 = rsp_length++;
        rsp[v21] = -1;
        str_len = 8;
        memcpy(&rsp[rsp_length], "LMB3.1.6", 8u);
        rsp_length += str_len;
        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
        break;
      case 22:
        mapping_address_5 = address - mb_mapping->start_registers;
        if ( mapping_address_5 >= 0 && mb_mapping->nb_registers > mapping_address_5 )
        {
          data_1 = mb_mapping->tab_registers[mapping_address_5];
          and = reqa[offset + 4] + (reqa[offset + 3] << 8);
          or = reqa[offset + 6] + (reqa[offset + 5] << 8);
          data_1 = or & ~and | and & data_1;
          mb_mapping->tab_registers[mapping_address_5] = data_1;
          memcpy(rsp, reqa, req_lengtha);
          rsp_length = req_lengtha;
        }
        else
        {
LABEL_60:
          rsp_length = response_exception(
                         ctxa,
                         &sft,
                         2,
                         rsp,
                         0,
                         "Illegal data address 0x%0X in write_register\n",
                         address);
        }
        break;
      case 23:
        nb_3 = (reqa[offset + 3] << 8) + reqa[offset + 4];
        address_write = reqa[offset + 6] + (reqa[offset + 5] << 8);
        nb_write = (reqa[offset + 7] << 8) + reqa[offset + 8];
        nb_write_bytes = reqa[offset + 9];
        mapping_address_6 = address - mb_mapping->start_registers;
        mapping_address_write = address_write - mb_mapping->start_registers;
        if ( nb_write > 0 && nb_write <= 121 && nb_3 > 0 && nb_3 <= 125 && 2 * nb_write == nb_write_bytes )
        {
          if ( mapping_address_6 >= 0
            && mapping_address_6 + nb_3 <= mb_mapping->nb_registers
            && mapping_address_write + nb_write <= mb_mapping->nb_registers )
          {
            v24 = ctxa->backend->build_response_basis(&sft, rsp);
            rsp_length = v24 + 1;
            rsp[v24] = 2 * nb_3;
            i_1 = mapping_address_write;
            j_0 = 10;
            while ( mapping_address_write + nb_write > i_1 )
            {
              mb_mapping->tab_registers[i_1++] = reqa[j_0 + 1 + offset] + (reqa[j_0 + offset] << 8);
              j_0 += 2;
            }
            for ( i_1 = mapping_address_6; mapping_address_6 + nb_3 > i_1; ++i_1 )
            {
              v25 = rsp_length++;
              rsp[v25] = HIBYTE(mb_mapping->tab_registers[i_1]);
              v26 = rsp_length++;
              rsp[v26] = mb_mapping->tab_registers[i_1];
            }
          }
          else
          {
            if ( mapping_address_6 >= 0 )
              v22 = nb_3 + address;
            else
              v22 = address;
            if ( mapping_address_write >= 0 )
              v23 = nb_write + address_write;
            else
              v23 = address_write;
            rsp_length = response_exception(
                           ctxa,
                           &sft,
                           2,
                           rsp,
                           0,
                           "Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n",
                           v22,
                           v23);
          }
        }
        else
        {
          rsp_length = response_exception(
                         ctxa,
                         &sft,
                         3,
                         rsp,
                         1u,
                         "Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n",
                         nb_write,
                         nb_3,
                         121,
                         125);
        }
        break;
      default:
        rsp_length = response_exception(ctxa, &sft, 1, rsp, 1u, "Unknown Modbus function code: 0x%0X\n", function);
        break;
    }
    if ( ctxa->backend->backend_type || slave )
      return send_msg(ctxa, rsp, rsp_length);
    else
      return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}
// A522: conditional instruction was optimized away because %mapping_address_6.4>=0

//----- (0000A724) --------------------------------------------------------
int __cdecl modbus_reply_exception(modbus_t *ctx, const uint8_t *req, unsigned int exception_code)
{
  int v4; // r3
  const uint8_t *reqa; // [sp+8h] [bp+8h]
  modbus_t *ctxa; // [sp+Ch] [bp+Ch]
  sft_t sft; // [sp+14h] [bp+14h] BYREF
  int dummy_length; // [sp+20h] [bp+20h] BYREF
  uint8_t rsp[260]; // [sp+24h] [bp+24h] BYREF
  int rsp_length; // [sp+128h] [bp+128h]
  int function; // [sp+12Ch] [bp+12Ch]
  int slave; // [sp+130h] [bp+130h]
  int offset; // [sp+134h] [bp+134h]

  ctxa = ctx;
  reqa = req;
  dummy_length = 99;
  if ( ctx )
  {
    offset = ctxa->backend->header_length;
    slave = reqa[offset - 1];
    function = reqa[offset];
    sft.slave = slave;
    sft.function = function + 128;
    sft.t_id = ctxa->backend->prepare_response_tid(reqa, &dummy_length);
    rsp_length = ctxa->backend->build_response_basis(&sft, rsp);
    if ( exception_code > 0xB )
    {
      *_errno_location() = 22;
      return -1;
    }
    else
    {
      v4 = rsp_length++;
      rsp[v4] = exception_code;
      return send_msg(ctxa, rsp, rsp_length);
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000A82C) --------------------------------------------------------
int __cdecl read_io_status(modbus_t *ctx, int function, int addr, int nb, uint8_t *dest)
{
  int v6; // r3
  uint8_t rsp[260]; // [sp+18h] [bp+10h] BYREF
  uint8_t req[12]; // [sp+11Ch] [bp+114h] BYREF
  int temp; // [sp+128h] [bp+120h]
  int offset_end; // [sp+12Ch] [bp+124h]
  int offset; // [sp+130h] [bp+128h]
  int req_length; // [sp+134h] [bp+12Ch]
  int pos; // [sp+138h] [bp+130h]
  int bit; // [sp+13Ch] [bp+134h]
  int i; // [sp+140h] [bp+138h]
  int rc; // [sp+144h] [bp+13Ch]

  req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);
  rc = send_msg(ctx, req, req_length);
  if ( rc <= 0 )
    return rc;
  pos = 0;
  rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
  if ( rc != -1 )
  {
    rc = check_confirmation(ctx, req, rsp, rc);
    if ( rc == -1 )
      return -1;
    offset = ctx->backend->header_length + 2;
    offset_end = rc + offset;
    for ( i = offset; i < offset_end; ++i )
    {
      temp = rsp[i];
      for ( bit = 1; (_BYTE)bit && pos < nb; bit *= 2 )
      {
        v6 = pos++;
        dest[v6] = (bit & temp) != 0;
      }
    }
    return rc;
  }
  return -1;
}

//----- (0000A98E) --------------------------------------------------------
int __cdecl modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)
{
  if ( ctx )
  {
    if ( nb <= 2000 )
    {
      if ( read_io_status(ctx, 1, addr, nb, dest) == -1 )
        return -1;
      else
        return nb;
    }
    else
    {
      if ( ctx->debug )
        fprintf(stderr, "ERROR Too many bits requested (%d > %d)\n", nb, 2000);
      *_errno_location() = 112345694;
      return -1;
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000AA28) --------------------------------------------------------
int __cdecl modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)
{
  if ( ctx )
  {
    if ( nb <= 2000 )
    {
      if ( read_io_status(ctx, 2, addr, nb, dest) == -1 )
        return -1;
      else
        return nb;
    }
    else
    {
      if ( ctx->debug )
        fprintf(stderr, "ERROR Too many discrete inputs requested (%d > %d)\n", nb, 2000);
      *_errno_location() = 112345694;
      return -1;
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000AAC0) --------------------------------------------------------
int __cdecl read_registers(modbus_t *ctx, int function, int addr, int nb, uint16_t *dest)
{
  uint8_t rsp[260]; // [sp+18h] [bp+10h] BYREF
  uint8_t req[12]; // [sp+11Ch] [bp+114h] BYREF
  int offset; // [sp+128h] [bp+120h]
  int req_length; // [sp+12Ch] [bp+124h]
  int i; // [sp+130h] [bp+128h]
  int rc; // [sp+134h] [bp+12Ch]

  if ( nb <= 125 )
  {
    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);
    rc = send_msg(ctx, req, req_length);
    if ( rc > 0 )
    {
      rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
      if ( rc == -1 )
        return -1;
      rc = check_confirmation(ctx, req, rsp, rc);
      if ( rc == -1 )
        return -1;
      offset = ctx->backend->header_length;
      for ( i = 0; i < rc; ++i )
        dest[i] = rsp[2 * i + 3 + offset] | (rsp[2 * i + 2 + offset] << 8);
    }
    return rc;
  }
  if ( ctx->debug )
    fprintf(stderr, "ERROR Too many registers requested (%d > %d)\n", nb, 125);
  *_errno_location() = 112345694;
  return -1;
}

//----- (0000AC3C) --------------------------------------------------------
int __cdecl modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest)
{
  if ( ctx )
  {
    if ( nb <= 125 )
    {
      return read_registers(ctx, 3, addr, nb, dest);
    }
    else
    {
      if ( ctx->debug )
        fprintf(stderr, "ERROR Too many registers requested (%d > %d)\n", nb, 125);
      *_errno_location() = 112345694;
      return -1;
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000ACC4) --------------------------------------------------------
int __cdecl modbus_read_input_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest)
{
  if ( ctx )
  {
    if ( nb <= 125 )
    {
      return read_registers(ctx, 4, addr, nb, dest);
    }
    else
    {
      fprintf(stderr, "ERROR Too many input registers requested (%d > %d)\n", nb, 125);
      *_errno_location() = 112345694;
      return -1;
    }
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000AD44) --------------------------------------------------------
int __cdecl write_single(modbus_t *ctx, int function, int addr, const uint16_t value)
{
  uint8_t rsp[260]; // [sp+18h] [bp+10h] BYREF
  uint8_t req[12]; // [sp+11Ch] [bp+114h] BYREF
  int req_length; // [sp+128h] [bp+120h]
  int rc; // [sp+12Ch] [bp+124h]

  if ( ctx )
  {
    req_length = ctx->backend->build_request_basis(ctx, function, addr, value, req);
    rc = send_msg(ctx, req, req_length);
    if ( rc > 0 )
    {
      rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
      if ( rc == -1 )
        return -1;
      return check_confirmation(ctx, req, rsp, rc);
    }
    return rc;
  }
  *_errno_location() = 22;
  return -1;
}

//----- (0000AE10) --------------------------------------------------------
int __cdecl modbus_write_bit(modbus_t *ctx, int addr, int status)
{
  uint16_t v4; // r3

  if ( ctx )
  {
    if ( status )
      v4 = -256;
    else
      v4 = 0;
    return write_single(ctx, 5, addr, v4);
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000AE54) --------------------------------------------------------
int __cdecl modbus_write_register(modbus_t *ctx, int addr, const uint16_t value)
{
  if ( ctx )
    return write_single(ctx, 6, addr, value);
  *_errno_location() = 22;
  return -1;
}

//----- (0000AE8E) --------------------------------------------------------
int __cdecl modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src)
{
  int v5; // r3
  int v6; // r3
  int v7; // r3
  uint8_t rsp[260]; // [sp+1Ch] [bp+14h] BYREF
  uint8_t req[260]; // [sp+120h] [bp+118h] BYREF
  int byte_count; // [sp+224h] [bp+21Ch]
  int bit; // [sp+228h] [bp+220h]
  int pos; // [sp+22Ch] [bp+224h]
  int bit_check; // [sp+230h] [bp+228h]
  int req_length; // [sp+234h] [bp+22Ch]
  int i; // [sp+238h] [bp+230h]
  int rc; // [sp+23Ch] [bp+234h]

  bit_check = 0;
  pos = 0;
  if ( ctx )
  {
    if ( nb <= 1968 )
    {
      req_length = ctx->backend->build_request_basis(ctx, 15, addr, nb, req);
      byte_count = ((nb & 7) != 0) + nb / 8;
      v5 = req_length++;
      req[v5] = byte_count;
      for ( i = 0; i < byte_count; ++i )
      {
        bit = 1;
        req[req_length] = 0;
        while ( (_BYTE)bit )
        {
          v7 = bit_check++;
          if ( v7 >= nb )
            break;
          v6 = pos++;
          if ( src[v6] )
            req[req_length] |= bit;
          else
            req[req_length] &= ~(_BYTE)bit;
          bit *= 2;
        }
        ++req_length;
      }
      rc = send_msg(ctx, req, req_length);
      if ( rc > 0 )
      {
        rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
        if ( rc == -1 )
          return -1;
        return check_confirmation(ctx, req, rsp, rc);
      }
      return rc;
    }
    if ( ctx->debug )
      fprintf(stderr, "ERROR Writing too many bits (%d > %d)\n", nb, 1968);
    *_errno_location() = 112345694;
    return -1;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B0C8) --------------------------------------------------------
int __cdecl modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src)
{
  int v5; // r0
  int v6; // r3
  int v7; // r3
  uint8_t rsp[260]; // [sp+18h] [bp+10h] BYREF
  uint8_t req[260]; // [sp+11Ch] [bp+114h] BYREF
  int byte_count; // [sp+220h] [bp+218h]
  int req_length; // [sp+224h] [bp+21Ch]
  int i; // [sp+228h] [bp+220h]
  int rc; // [sp+22Ch] [bp+224h]

  if ( ctx )
  {
    if ( nb <= 123 )
    {
      v5 = ctx->backend->build_request_basis(ctx, 16, addr, nb, req);
      byte_count = 2 * nb;
      req_length = v5 + 1;
      req[v5] = 2 * nb;
      for ( i = 0; i < nb; ++i )
      {
        v6 = req_length++;
        req[v6] = HIBYTE(src[i]);
        v7 = req_length++;
        req[v7] = src[i];
      }
      rc = send_msg(ctx, req, req_length);
      if ( rc > 0 )
      {
        rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
        if ( rc == -1 )
          return -1;
        return check_confirmation(ctx, req, rsp, rc);
      }
      return rc;
    }
    if ( ctx->debug )
      fprintf(stderr, "ERROR Trying to write to too many registers (%d > %d)\n", nb, 123);
    *_errno_location() = 112345694;
    return -1;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B260) --------------------------------------------------------
int __cdecl modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask, uint16_t or_mask)
{
  int v4; // r0
  int v5; // r3
  int v6; // r3
  int v7; // r3
  uint8_t rsp[260]; // [sp+1Ch] [bp+14h] BYREF
  uint8_t req[16]; // [sp+120h] [bp+118h] BYREF
  int req_length; // [sp+130h] [bp+128h]
  int rc; // [sp+134h] [bp+12Ch]
  _BYTE v17[4]; // [sp+138h] [bp+130h] BYREF

  v4 = ctx->backend->build_request_basis(ctx, 22, addr, 0, req);
  req_length = v4 - 1;
  v17[v4 - 26] = HIBYTE(and_mask);
  v5 = req_length++;
  v17[v5 - 24] = and_mask;
  v6 = req_length++;
  v17[v6 - 24] = HIBYTE(or_mask);
  v7 = req_length++;
  v17[v7 - 24] = or_mask;
  rc = send_msg(ctx, req, req_length);
  if ( rc <= 0 )
    return rc;
  rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
  if ( rc != -1 )
    return check_confirmation(ctx, req, rsp, rc);
  return -1;
}

//----- (0000B388) --------------------------------------------------------
int __cdecl modbus_write_and_read_registers(
        modbus_t *ctx,
        int write_addr,
        int write_nb,
        const uint16_t *src,
        int read_addr,
        int read_nb,
        uint16_t *dest)
{
  int v8; // r0
  int v9; // r3
  int v10; // r3
  int v11; // r3
  int v12; // r3
  int v13; // r3
  int v14; // r3
  __int16 write_addra; // [sp+10h] [bp+8h]
  uint8_t rsp[260]; // [sp+1Ch] [bp+14h] BYREF
  uint8_t req[260]; // [sp+120h] [bp+118h] BYREF
  int offset; // [sp+224h] [bp+21Ch]
  int byte_count; // [sp+228h] [bp+220h]
  int i; // [sp+22Ch] [bp+224h]
  int req_length; // [sp+230h] [bp+228h]
  int rc; // [sp+234h] [bp+22Ch]

  write_addra = write_addr;
  if ( ctx )
  {
    if ( write_nb <= 121 )
    {
      if ( read_nb <= 125 )
      {
        v8 = ctx->backend->build_request_basis(ctx, 23, read_addr, read_nb, req);
        req_length = v8 + 1;
        req[v8] = HIBYTE(write_addra);
        v9 = req_length++;
        req[v9] = write_addra;
        v10 = req_length++;
        req[v10] = BYTE1(write_nb);
        v11 = req_length++;
        req[v11] = write_nb;
        byte_count = 2 * write_nb;
        v12 = req_length++;
        req[v12] = 2 * write_nb;
        for ( i = 0; i < write_nb; ++i )
        {
          v13 = req_length++;
          req[v13] = HIBYTE(src[i]);
          v14 = req_length++;
          req[v14] = src[i];
        }
        rc = send_msg(ctx, req, req_length);
        if ( rc > 0 )
        {
          rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
          if ( rc == -1 )
            return -1;
          rc = check_confirmation(ctx, req, rsp, rc);
          if ( rc == -1 )
            return -1;
          offset = ctx->backend->header_length;
          for ( i = 0; i < rc; ++i )
            dest[i] = rsp[2 * i + 3 + offset] | (rsp[2 * i + 2 + offset] << 8);
        }
        return rc;
      }
      if ( ctx->debug )
        fprintf(stderr, "ERROR Too many registers requested (%d > %d)\n", read_nb, 125);
    }
    else if ( ctx->debug )
    {
      fprintf(stderr, "ERROR Too many registers to write (%d > %d)\n", write_nb, 121);
    }
    *_errno_location() = 112345694;
    return -1;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B640) --------------------------------------------------------
int __cdecl modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest)
{
  uint8_t rsp[260]; // [sp+18h] [bp+10h] BYREF
  uint8_t req[12]; // [sp+11Ch] [bp+114h] BYREF
  int offset; // [sp+128h] [bp+120h]
  int req_length; // [sp+12Ch] [bp+124h]
  int i; // [sp+130h] [bp+128h]
  int rc; // [sp+134h] [bp+12Ch]

  if ( ctx && max_dest > 0 )
  {
    req_length = ctx->backend->build_request_basis(ctx, 17, 0, 0, req) - 4;
    rc = send_msg(ctx, req, req_length);
    if ( rc > 0 )
    {
      rc = j__modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);
      if ( rc == -1 )
        return -1;
      rc = check_confirmation(ctx, req, rsp, rc);
      if ( rc == -1 )
        return -1;
      offset = ctx->backend->header_length + 2;
      for ( i = 0; i < rc && i < max_dest; ++i )
        dest[i] = rsp[i + offset];
    }
    return rc;
  }
  *_errno_location() = 22;
  return -1;
}

//----- (0000B778) --------------------------------------------------------
void __cdecl modbus_init_common(modbus_t *ctx)
{
  ctx->slave = -1;
  ctx->s = -1;
  ctx->debug = 0;
  ctx->error_recovery = 0;
  ctx->response_timeout.tv_sec = 0;
  ctx->response_timeout.tv_usec = 500000;
  ctx->byte_timeout.tv_sec = 0;
  ctx->byte_timeout.tv_usec = 500000;
  ctx->indication_timeout.tv_sec = 0;
  ctx->indication_timeout.tv_usec = 0;
}

//----- (0000B7D8) --------------------------------------------------------
int __cdecl modbus_set_slave(modbus_t *ctx, int slave)
{
  if ( ctx )
    return ctx->backend->set_slave(ctx, slave);
  *_errno_location() = 22;
  return -1;
}

//----- (0000B80E) --------------------------------------------------------
int __cdecl modbus_get_slave(modbus_t *ctx)
{
  if ( ctx )
    return ctx->slave;
  *_errno_location() = 22;
  return -1;
}

//----- (0000B838) --------------------------------------------------------
int __cdecl modbus_set_error_recovery(modbus_t *ctx, modbus_error_recovery_mode error_recovery)
{
  if ( ctx )
  {
    ctx->error_recovery = (unsigned __int8)error_recovery;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B86C) --------------------------------------------------------
int __cdecl modbus_set_socket(modbus_t *ctx, int s)
{
  if ( ctx )
  {
    ctx->s = s;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B89C) --------------------------------------------------------
int __cdecl modbus_get_socket(modbus_t *ctx)
{
  if ( ctx )
    return ctx->s;
  *_errno_location() = 22;
  return -1;
}

//----- (0000B8C6) --------------------------------------------------------
int __cdecl modbus_get_response_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)
{
  if ( ctx )
  {
    *(timeval *)to_sec = ctx->response_timeout;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B906) --------------------------------------------------------
int __cdecl modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)
{
  if ( ctx && (to_sec || to_usec) && to_usec <= 0xF423F )
  {
    ctx->response_timeout.tv_sec = to_sec;
    ctx->response_timeout.tv_usec = to_usec;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B958) --------------------------------------------------------
int __cdecl modbus_get_byte_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)
{
  if ( ctx )
  {
    *(timeval *)to_sec = ctx->byte_timeout;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B998) --------------------------------------------------------
int __cdecl modbus_set_byte_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)
{
  if ( ctx && to_usec <= 0xF423F )
  {
    ctx->byte_timeout.tv_sec = to_sec;
    ctx->byte_timeout.tv_usec = to_usec;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000B9DE) --------------------------------------------------------
int __cdecl modbus_get_indication_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)
{
  if ( ctx )
  {
    *(timeval *)to_sec = ctx->indication_timeout;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000BA1E) --------------------------------------------------------
int __cdecl modbus_set_indication_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)
{
  if ( ctx && to_usec <= 0xF423F )
  {
    ctx->indication_timeout.tv_sec = to_sec;
    ctx->indication_timeout.tv_usec = to_usec;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000BA64) --------------------------------------------------------
int __cdecl modbus_get_header_length(modbus_t *ctx)
{
  if ( ctx )
    return ctx->backend->header_length;
  *_errno_location() = 22;
  return -1;
}

//----- (0000BA90) --------------------------------------------------------
int __cdecl modbus_connect(modbus_t *ctx)
{
  if ( ctx )
    return ctx->backend->connect(ctx);
  *_errno_location() = 22;
  return -1;
}

//----- (0000BAC2) --------------------------------------------------------
void __cdecl modbus_close(modbus_t *ctx)
{
  if ( ctx )
    ctx->backend->close(ctx);
}

//----- (0000BAE4) --------------------------------------------------------
void __cdecl modbus_free(modbus_t *ctx)
{
  if ( ctx )
    ctx->backend->free(ctx);
}

//----- (0000BB06) --------------------------------------------------------
int __cdecl modbus_set_debug(modbus_t *ctx, int flag)
{
  if ( ctx )
  {
    ctx->debug = flag;
    return 0;
  }
  else
  {
    *_errno_location() = 22;
    return -1;
  }
}

//----- (0000BB36) --------------------------------------------------------
modbus_mapping_t *__cdecl modbus_mapping_new_start_address(
        unsigned int start_bits,
        unsigned int nb_bits,
        unsigned int start_input_bits,
        unsigned int nb_input_bits,
        unsigned int start_registers,
        unsigned int nb_registers,
        unsigned int start_input_registers,
        unsigned int nb_input_registers)
{
  modbus_mapping_t *mb_mapping; // [sp+14h] [bp+14h]

  mb_mapping = (modbus_mapping_t *)malloc(0x30u);
  if ( mb_mapping )
  {
    mb_mapping->nb_bits = nb_bits;
    mb_mapping->start_bits = start_bits;
    if ( nb_bits )
    {
      mb_mapping->tab_bits = (uint8_t *)malloc(nb_bits);
      if ( !mb_mapping->tab_bits )
      {
        free(mb_mapping);
        return 0;
      }
      memset(mb_mapping->tab_bits, 0, nb_bits);
    }
    else
    {
      mb_mapping->tab_bits = 0;
    }
    mb_mapping->nb_input_bits = nb_input_bits;
    mb_mapping->start_input_bits = start_input_bits;
    if ( nb_input_bits )
    {
      mb_mapping->tab_input_bits = (uint8_t *)malloc(nb_input_bits);
      if ( !mb_mapping->tab_input_bits )
      {
        free(mb_mapping->tab_bits);
        free(mb_mapping);
        return 0;
      }
      memset(mb_mapping->tab_input_bits, 0, nb_input_bits);
    }
    else
    {
      mb_mapping->tab_input_bits = 0;
    }
    mb_mapping->nb_registers = nb_registers;
    mb_mapping->start_registers = start_registers;
    if ( nb_registers )
    {
      mb_mapping->tab_registers = (uint16_t *)malloc(2 * nb_registers);
      if ( !mb_mapping->tab_registers )
      {
        free(mb_mapping->tab_input_bits);
        free(mb_mapping->tab_bits);
        free(mb_mapping);
        return 0;
      }
      memset(mb_mapping->tab_registers, 0, 2 * nb_registers);
    }
    else
    {
      mb_mapping->tab_registers = 0;
    }
    mb_mapping->nb_input_registers = nb_input_registers;
    mb_mapping->start_input_registers = start_input_registers;
    if ( nb_input_registers )
    {
      mb_mapping->tab_input_registers = (uint16_t *)malloc(2 * nb_input_registers);
      if ( !mb_mapping->tab_input_registers )
      {
        free(mb_mapping->tab_registers);
        free(mb_mapping->tab_input_bits);
        free(mb_mapping->tab_bits);
        free(mb_mapping);
        return 0;
      }
      memset(mb_mapping->tab_input_registers, 0, 2 * nb_input_registers);
    }
    else
    {
      mb_mapping->tab_input_registers = 0;
    }
    return mb_mapping;
  }
  return 0;
}

//----- (0000BCCA) --------------------------------------------------------
modbus_mapping_t *__cdecl modbus_mapping_new(int nb_bits, int nb_input_bits, int nb_registers, int nb_input_registers)
{
  return j_modbus_mapping_new_start_address(0, nb_bits, 0, nb_input_bits, 0, nb_registers, 0, nb_input_registers);
}

//----- (0000BD00) --------------------------------------------------------
void __cdecl modbus_mapping_free(modbus_mapping_t *mb_mapping)
{
  if ( mb_mapping )
  {
    free(mb_mapping->tab_input_registers);
    free(mb_mapping->tab_registers);
    free(mb_mapping->tab_input_bits);
    free(mb_mapping->tab_bits);
    free(mb_mapping);
  }
}

//----- (0000BD46) --------------------------------------------------------
size_t __cdecl strlcpy(char *dest, const char *src, size_t dest_size)
{
  const char *v4; // r5
  size_t v5; // r4
  char *v6; // r3
  char *v7; // r2
  const char *v8; // r3

  v4 = src;
  v5 = dest_size;
  if ( dest_size )
  {
    v5 = dest_size - 1;
    if ( dest_size != 1 )
    {
      do
      {
        v6 = dest++;
        v7 = (char *)v4++;
        *v6 = *v7;
        if ( !*v6 )
          break;
        --v5;
      }
      while ( v5 );
    }
  }
  if ( !v5 )
  {
    if ( dest_size )
      *dest = 0;
    do
      v8 = v4++;
    while ( *v8 );
  }
  return v4 - src - 1;
}

//----- (0000BDAC) --------------------------------------------------------
int __fastcall fstat(int fildes, struct stat *stat_buf)
{
  return j___fxstat(3, fildes, stat_buf);
}

//----- (0000BDBE) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_BE00 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// BDC2: variable 'v2' is possibly undefined

//----- (0000C068) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (0000C074) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=350 queued=194 decompiled=194 lumina nreq=0 worse=0 better=0
// ALL OK, 194 function(s) have been successfully decompiled
